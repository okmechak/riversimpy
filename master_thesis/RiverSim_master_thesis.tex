\documentclass[]{pracamgr}

\usepackage{tcolorbox} 

\tcbuselibrary{minted,breakable,xparse,skins}
\tcbuselibrary{minted, breakable, xparse, skins}
\definecolor{bg}{gray}{0.95}
\DeclareTCBListing{mintedbox}{O{}m!O{}}{%
  breakable=true,
  listing engine=minted,
  listing only,
  minted language=#2,
  minted style=default,
  minted options={%
    linenos,
    gobble=0,
    breaklines=true,
    breakafter=,,
    fontsize=\small,
    numbersep=8pt,
    #1},
  boxsep=0pt,
  left skip=0pt,
  right skip=0pt,
  left=10pt,
  right=0pt,
  top=3pt,
  bottom=3pt,
  arc=5pt,
  leftrule=0pt,
  rightrule=0pt,
  bottomrule=2pt,
  toprule=2pt,
  colback=bg,
  colframe=white!10,
  enhanced,
  overlay={%
    \begin{tcbclipinterior}
    \fill[white!10!white] (frame.south west) rectangle ([xshift=20pt]frame.north west);
    \end{tcbclipinterior}},
  #3}

\usepackage[utf8]{inputenc}
\usepackage{wrapfig}
\usepackage{graphicx}
\usepackage{subfig}
\usepackage{float}
\usepackage{amsmath}
\usepackage{cite}
\usepackage{listings} %c++ code snippet
\usepackage{xcolor} %c++ code snippet
\lstset { %
    language=C++,
    %backgroundcolor=\color{black!5}, % set backgroundcolor
    basicstyle=\footnotesize,% basic font setting
} %c++ code

\begin{document}
  
  \maketitle

  %tu idzie streszczenie na strone poczatkowa
  \begin{abstract}
    %Мережі в натуральний спосіб з'являються повсюдно в природі. Електростатичний розряд між двома зарядженими областями породжує струм котрий утворює мережу каналів. Дерево зростаючи утворює розгалужену мережу гілок для збору сонячної енергії в ефективний спосіб на протязі багатьох років. Також розвиток мережі судин є керований концентрацією кисню в тканині. 
    Sieci naturalnie pojawiają się wszędzie w przyrodzie. Wyładowanie elektrostatyczne między dwoma naładowanymi obszarami generuje prąd, który tworzy sieć kanałów. W miarę wzrostu drzewo tworzy rozległą sieć gałęzi, które efektywnie gromadzą energię słoneczną przez wiele lat. Również rozwój sieci naczyniowej jest kontrolowany przez stężenie tlenu w tkance.\par

    %На цьому етапі вже можна побачити деяку спільну рису між всіма процесами, а саме наявність взаємозалежних поля і матерії на котра переміщається в локальному напрямку максимального поля. Тому багато процесів із розвитку мережі можна звести до одного математичного формалізму. 
    Na tym etapie można już dostrzec pewną wspólną cechę wszystkich procesów, a mianowicie obecność współzależnych pól i materii poruszającej się w lokalnym kierunku maksymalnego pola. Dlatego wiele procesów rozwoju sieci można sprowadzić do jednego formalizmu matematycznego.\par

    %В даній праці ми фокусуємося на створенні Python бібліотеки котра помагає досліджувати розвиток мережі в полі Лапласа на прикладі розвитку мережі річки. Спочатку ми описуємо математичну модель розвитку мережі річки в полі Лапласа. Тоді описуємо бібліотеку riversim, її алгоритми і показуємо простий спосіб застосування програми крок по кроку. Тоді наводимо приклади збіжності розв'язку і покажемо кілька результатів.
    W tej pracy skupiamy się na stworzeniu biblioteki Pythona, która pomaga badać rozwój sieci w polu Laplace'a na przykładzie rozwoju sieci rzecznej. Najpierw opisujemy matematyczny model rozwoju sieci rzecznej w polu Laplace'a. Następnie opisujemy bibliotekę riversim, jej algorytmy i pokazujemy prosty sposób korzystania z programu krok po kroku. Następnie podajemy przykłady zbieżności rozwiązania i pokazujemy kilka wyników.\par

  \end{abstract}

  \tableofcontents

  %\chapter*{Wprowadzenie}

  %  \addcontentsline{toc}{chapter}{Wprowadzenie}
  %  \pagenumbering{arabic}
  %  \setcounter{page}{1} 

  %  Wiele naturalnych wzorców ma postać sieci rozgałęzionych: od sieci rzecznych lub kanałów jaskiniowych, dendrytów mineralnych i lepkich wzorców palców do systemów biologicznych, takich jak naczynia krwionośne lub żyłkowanie liści i wiele innych (Rys. \ref{networks_in_nature}). Siły fizyczne napędzające wzrost różni się w zależności od systemu: erozja, dyfuzja, przewodnictwo cieplne i in. Pomimo tych różnic istnieje wiele cech wspólnych dla tych sieci, to sugeruje wspólny podstawowy mechanizm wzrostu.\par

  %  \begin{figure}[H]
  %    \centering
  %    \subfloat[]{\label{cracks}
  %    \includegraphics[height=0.19\textheight]{figs/lichtenberg_figure.jpg}}
  %    \quad
  %    \subfloat[]{\label{chicken}
  %    \includegraphics[height=0.19\textheight]{figs/dry_tug_fork_california.png}}
  %    \quad
  %    %\hspace{-10pt}
  %    \subfloat[]{\label{leaf}
  %    \includegraphics[height=0.19\textheight]{figs/chicken_yolk_sac.png}}
  %    \caption{Przykłady rozgałęzionych sieci przestrzennych w przyrodzie: (a)~Figura Lichtenberga \cite{paulslab} (b)~Dorzecze Dry Tug Fork w Kalifornii \cite{ball2009branches} (c)~Naczynia krwionośne na worku żółtkowym \cite{Clement2017tissue} (podziękowania dla Annemiek JM Cornelissen)}
  %    \label{networks_in_nature}
  %  \end{figure}
 
  %    Istotną cechą rozwoju sieci jest ścisłe sprzężenie pomiędzy geometrią a dynamiką. Środowisko napędzające wzrost i sieć współewoluują w czasie, w miarę ewolucji sieć zmienia warunki brzegowe dla pola. Rozwój sieci w odpowiedzi na otaczające pole składa się z dwóch głównych procesów: (i) rozszerzenie gałęzi oraz (ii) rozwidlenie końcówki na dwie (lub więcej) gałęzie. Aby zrozumieć koewolucja sieci i pola, ważne jest  zrozumieć w jaki sposób wzrost i procesy bifurkacyjne są powiązane z charakterystyką pól napędowych, takich jak na przykład gradient pola w okolicy czubka. Gdy poznamy \textit{zasady wzrostu}, możemy przewidzieć ewolucję geometrii sieci na podstawie jej wcześniejszej konfiguracji. \par
      
  %    Taką procedurę zastosowano do sieci rzecznych \cite{devauchelle2012ramification, petroff2013bifurcation, cohen2015path, yi2017symmetric, devauchelle2017laplacian}, lepkich palców \cite{pecelerowicz2016stabilizing} lub wzrost koralowców \cite{kaandorp2001algorithmic_Chapter4.4}, co prowadzi do jakościowo i ilościowo zbliżonych geometrii sieci do tych obserwowanych w przyrodzie. Jednak w wielu praktycznych przypadkach szczegóły reguł wzrostu są: nieznany, a czasową ewolucję wzorca można zaobserwować tylko w jednym przypadku czasu, ponieważ dynamika wzrostu może być po prostu zbyt wolna, jak np. w przypadku rzeki sieci, w których końcówki kanałów mogą poruszać się z prędkością mniejszą niż kilka milimetrów rocznie. Rodzi to następujące pytanie: czy możemy wydedukować regułę wzrostu z chwilowego 1 migawka konfiguracji sieci i opis ewolucji otaczającego środowiska w odpowiedzi na geometrię sieci? Rzeczywiście, geometria sieci ukrywa informacje o jego przeszłej konfiguracji, która jest nieodłącznie związana z dynamiką wzrostu.

  %    TODO: tutaj trzeba opisać mój przypadek.

  \chapter{Model teoretyczny}
    
    %Model wzrostu rzeki jest przykładem wzrostu w odpowiedzi na pole dyfuzji. Pole jest połączone z siecią rzeczną za pomocą warunków brzegowych. Taki połączony układ pól i sieci może opisywać wiele innych naturalnych procesów wzrostu, takich jak wyładowania elektryczne \cite{niemeyer1984fractal}, tworzenie naczyń krwionośnych \cite{nguyen2006dynamics}, wzorce rozpuszczania w ośrodkach porowatych \cite{szymczak2011initial} i inne. W przypadku sieci rzecznych pole opisuje wysokość poziomu wód gruntowych.
    Model wzrostu rzeki jest przykładem wzrostu w odpowiedzi na pole dyfuzji. Pole jest połączone z siecią rzeczną za pomocą warunków brzegowych. Taki połączony układ pól i sieci może opisywać wiele innych naturalnych procesów wzrostu, takich jak wyładowania elektryczne \cite{niemeyer1984fractal}, tworzenie naczyń krwionośnych \cite{nguyen2006dynamics}, wzorce rozpuszczania w ośrodkach porowatych \cite{szymczak2011initial} i inne. W przypadku sieci rzecznych pole opisuje wysokość poziomu wód gruntowych.

    %Говорячи про річкові мережі, вода може надходити в річку двома різними шляхами: (i) через поверхневий стік або (ii) через резервуар підземних вод. У першому випадку вода (зазвичай з опадів) не занурюється в землю, а стікає поверхнею прямо в русло (світло-блакитні стрілки на рис. ~\ref{pow_soaking}). Такий сценарій можна спостерігати в районах, де грунт водонепроникний, а опади настільки інтенсивні, що вода не встигає зануритися в землю.
    Jeśli chodzi o sieci rzeczne, woda może wpływać do rzeki na dwa różne sposoby: (i) przez spływ powierzchniowy lub (ii) przez zbiornik wód podziemnych. W pierwszym przypadku woda (zwykle pochodząca z opadów atmosferycznych) nie wsiąka w ziemię, lecz przepływa po powierzchni bezpośrednio do kanału (niebieskie strzałki na ryc. ~\ref{pow_wsiakanie}). Taki scenariusz można zaobserwować na obszarach, gdzie gleba jest nieprzepuszczalna, a opady są tak intensywne, że woda nie ma czasu wsiąknąć w ziemię.

    \begin{figure}[H]
      \centering
      \includegraphics[width=1\textwidth]{figs/basic_river_illustration.png}
      \caption { TODO }
      \label{pow_wsiakanie}
    \end{figure}

    %Однак, якщо ґрунт достатньо проникний, вода може занурюватися в землю, а не стікати вниз (темно-сині стрілки на рис. \ref{float_soaking}). Вода спочатку накопичується в підземній водоймі, а потім під дією гідродинамічного тиску витікає з річкового джерела і берегів. Цей процес утворює ерозію ґрунту в околиці джерела.
    Jeśli jednak gleba jest wystarczająco przepuszczalna, woda może wsiąkać w ziemię, zamiast spływać (ryc. \ref{pow_wsiakanie}). Woda najpierw gromadzi się w podziemnym zbiorniku, a następnie wypływa ze źródła rzeki i brzegów pod wpływem ciśnienia hydrodynamicznego. Proces ten powoduje erozję gleby w pobliżu źródła.

    \begin{wrapfigure}{r}{0.5\textwidth}
      \begin{center}
        \vspace{-20pt}
        \includegraphics[width=0.45\textwidth]{figs/erosion_illustration.png}
      \end{center}
      \vspace{-20pt}
      \caption{ TODO }
      \vspace{0pt}
      \label{zrodlo}
    \end{wrapfigure}

    %Ця ерозія в околиці джерела, котра відбувається в протилежному напрямку до течії відповідає за розширення та роздвоєння річки (біфуркація), загальну еволюцію річкової мережі.
    Ta erozja w pobliżu źródła, która zachodzi w kierunku przeciwnym do nurtu, jest odpowiedzialna za ekspansję i bifurkację rzeki, ogólną ewolucję sieci rzecznej.

    %Перша кількісна модель, що описує еволюцію таких річок, була представлена ​​в 1980 році Данном \cite{dunne1980formation}. Більш детальні моделі були запропоновані групою Даніеля Ротмана з Массачусетського технологічного інституту (Refs.~\cite{petroff2012four, devauchelle2012ramification}). Автори пов’язали висоту рівня ґрунтових вод із напрямком і швидкістю зростання річки.
    Pierwszy ilościowy model opisujący ewolucję takich rzek przedstawił w 1980 roku Dunne \cite{dunne1980formation}. Bardziej szczegółowe modele zostały zaproponowane przez grupę Daniela Rothmana z Massachusetts Institute of Technology (Refs.~\cite{petroff2012four, devauchelle2012ramification}). Autorzy powiązali wysokość poziomu wód gruntowych z kierunkiem i szybkością wzrostu rzeki.

    %Остання модель передбачає однорідність проникної здатності і сталу висоту ґрунту, ширина річки вважається достатньо малою, а тому апроксимується лінією, а процес ерозії розглядають лише в околиці джерела.
    Ten drugi model zakłada jednorodność przepuszczalności i stałą wysokość gruntu, szerokość rzeki uważa się za wystarczająco małą i dlatego jest przybliżona linią \cite{peterson1998singular,carleson2002laplacian,gubiec2008fingered}, a proces erozji uwzględnia się tylko w pobliżu źródła.

    \section{Wody podziemne}

      Wodę zgromadzoną w zbiorniku wód podziemnych opisuje prawo Darcy'ego \cite{darcy1856fontaines}:
      
      \begin{equation}
        \vec{u}=-\frac{\kappa}{\mu} \nabla p
      \end{equation}	
      
      Równanie to opisuje prędkość filtracji ($\vec{u}$) płynu o lepkości dynamicznej $\mu$ przez ośrodek porowaty (np. piasek lub skały) o przepuszczalności $\kappa$ pod ciśnieniem $p$. 
    
      Aby obliczyć, ile wody przepływa przez określony punkt na płaszczyźnie $xy$, gdzie sieć się rozrasta, po prostu całkujemy prędkość Darcy'ego w danych współrzędnych $xy$ wzdłuż osi poziomej $z$ (wysokość zbiornika):
      
      \begin{equation}
        \vec{q}(x,y)=\int \vec{u}(x,y,z)\textrm{d}z
      \end{equation}
    
      Teraz korzystamy z założenia Dupuit \cite{dupuit1863etudes}, które mówi, że wody gruntowe płyną poziomo. Ponadto zakładamy, że ciśnienie powodujące przepływ jest po prostu ciśnieniem hydrostatycznym $p = \rho g h $ ($\rho$ -- gęstość wody, $g$ -- przyspieszenie grawitacyjne, $h$ -- wysokość Tabela wód podziemnych). Dla takiego ciśnienia $\nabla p$ jest niezależne od współrzędnej $z$, a powyższa całka upraszcza się do iloczynu prędkości filtracji $\vec{u}$ i wysokości słupa wody $h(x, y)$ w danym miejscu:
      
      \begin{equation}
        \label{qq}
        \vec{q}(x,y)=h\vec{u}=-h \frac{\kappa}{\mu} \nabla(\rho g h)=-\nabla \left(\frac{\kappa \rho g}{2\mu}h^2(x,y)\right) = - \nabla \phi(x,y) \,,
      \end{equation}
      
      gdzie wprowadziliśmy potencjał $\phi(x,y)$:
      
      \begin{equation}
        \phi(x,y) = \frac{\kappa \rho g}{2\mu}h^2(x,y) \,.
      \end{equation}
    
      Na koniec wyprowadzamy równania opisujące pole $\phi$ z równania ciągłości, uwzględniając opady (opisane przez średnią objętość opadów na jednostkę czasu i powierzchnię — $P$). Zmianę masy kolumny płynu ($M$) zamkniętej w obszarze $S$ można opisać następująco:

      \begin{gather*}
        \frac{\partial M}{\partial t}=- \int\limits_{\partial S} \vec{q}\cdot \hat{n} \ \textrm{d}l + \int\limits_S P \ \textrm{d}S
        \\
        \frac{\partial}{\partial t} \int\limits_S \rho h \ \textrm{d}S=\int\limits_S \left(-\nabla \cdot \vec{q} + P\right)\textrm{d}S
        \\
        \rho \frac{\partial h}{\partial t}=-\nabla \cdot \vec{q} + P
      \end{gather*}	

      W tym miejscu należy skomentować skale czasowe w rzeczywistych systemach. Średni czas między opadami to 10 dni, a średni czas przepływu wody przez system to $10^4$ dni. Oznacza to, że wahania wysokości zwierciadła wód gruntowych $h$ są bardzo małe i jako $P$ możemy przyjąć średnią roczną wielkość opadów. Ponadto szybkość wzrostu sieci rzecznej szacuje się na około 1~mm/rok, a charakterystyczny czas zmian geometrii to $10^4$ lat. To z kolei oznacza, że w skalach czasowych odpowiadających wzrostowi sieci rzecznej możemy pominąć $ \frac{\partial h} {\partial t} $ w równaniu ciągłości, otrzymując:
      
      \begin{equation}
    		\nabla \cdot \vec{q} = P \,.
    	\end{equation}
      
      Używając wcześniej zdefiniowanego potencjału $\phi$ otrzymujemy równanie Poissona:
      
      \begin{equation}
        \label{poisson}
    		\Delta \phi = -P/\kappa
    	\end{equation}
      
      lub równanie Laplace'a, gdzie nie ma opadów ($P=0$):
      
      \begin{equation}
        \label{laplace}
    		\Delta \phi = 0 \,.
    	\end{equation}	

      Równania te muszą być uzupełnione odpowiednimi warunkami brzegowymi. W naszym przypadku zakładamy, że rzeka płynie bezpośrednio po warstwie nieprzepuszczalnej (przy $h = 0$), czyli $\phi = 0$ na całej jej długości. Dodatkowo granice domeny są często nieprzepuszczalne, co można zapisać jako odblaskowy warunek brzegowy ($\frac{\partial \phi}{\partial \vec{n}} = 0$). Wreszcie, gdy nie ma opadów, zakładamy, że woda wchodzi do układu przez jedną z granic (na przykład z odległych lodowców) -- można to opisać jako stały przepływ pola $\phi$ wzdłuż rozważanej ściany ($\frac{\partial \phi}{\partial \vec{n}} = const.$).
      
      W ten sposób udało nam się zredukować trójwymiarowy problem przepływu płynów do obliczenia dwuwymiarowego potencjału, który niesie pełną informację o dynamice wód gruntowych.

    %\section{Przybliżenie rzeki cienkim palcem}

    %  Aby wyjaśnić przejście od dwuwymiarowych rzek do jednowymiarowych obiektów je reprezentujących, tak zwanych cienkich palców, posłużymy się innym przykładem procesu wzrostu w odpowiedzi na pole Laplace'a -- lepkim palcowaniem. Ten podstawowy, hydrodynamiczny przykład wzrostu Laplace'a został sformułowany przez Muskata w 1937 r. \cite{muskat1937flow} i opisuje ewolucję granicy faz między dwiema fazami -- na przykład dwoma płynami, gdzie jedna najeżdża i wypycha drugą. W tym konkretnym przypadku pole $\phi$ to ciśnienie, a $\kappa$ to współczynnik ruchliwości. Pomijając ruchliwości fazy inwazyjnej prowadzi do uproszczonej jednofazowej wersji tego problemu z warunkiem brzegowym Dirichleta na rosnącej powierzchni międzyfazowej. Zatem front ruchomy jest izolinią pola ciśnienia ($\phi = 0$). Front rośnie wzdłuż linii pola z prędkością ($\vec{v}$) proporcjonalną do gradientu pola ciśnienia:
      
    %  \begin{equation}
    %    \vec{v} \propto \nabla \phi
    %  \end{equation}

    %  W niektórych przypadkach front inwazyjny staje się niestabilny, co prowadzi do powstania tzw. palców. Niestabilności pojawiające się w takim układzie zostały przeanalizowane przez Hilla w 1952 roku w swojej pracy na temat wypierania cieczy cukrowej przez wodę w procesie rafinacji cukru \cite{hill1952channeling}. Jednak prawdziwe zainteresowanie zjawiskiem lepkiego palcowania pojawiło się w 1958 r. wraz z przełomowym artykułem Saffmana i Taylora \cite{saffman1958penetration}, w którym systematycznie badali pojawianie się wzorców w komórkach Hele-Shaw. Badana przez nich niestabilność stała się później znana jako niestabilność Saffmana-Taylora.

    %  Istnieje wiele zastosowań tego czysto hydrodynamicznego zjawiska i stojącej za nim matematyki w innych dziedzinach, takich jak tworzenie płuc \cite{clement2012branching,lubkin1995mechanism}, tworzenie jaskiń \cite{szymczak2011initial}, wzrost kolonii bakterii \cite{matsushita1990diffusion}, metaliczne dendryty rosną przez osadzanie elektrochemiczne \cite{brady1984fractal}, palcy spalania \cite{zik1999fingering}, przebudowę naczyń krwionośnych w woreczku żółtkowym podczas rozwoju zarodka kurczaka \cite{nguyen2006dynamics} lub naczynia krwionośne w nas \cite{schneider2012tissue}. Systemy te są zwykle opisywane jako ewolucja ciągłego interfejsu między dwiema fazami (rys. \ref{continuous_to_thin}) z pewnym mechanizmem regularyzacji na małą skalę, takim jak napięcie powierzchniowe. Bez tej regularyzacji strumień pola skoncentrowany na końcach faworyzuje bardzo cienkie palce i prowadzi do ich nieskończenie szybkiego wzrostu -- tak zwanej katastrofy ultrafioletowej \cite{shraiman1988singularities}.

    %  Istnieje jednak również inny sposób na uniknięcie katastrofy ultrafioletowej, który nie wiąże się z napięciem powierzchniowym. Dokładnie jak piorunochron chroniący budynki przyciąga pioruny, końcówki palców w sieciach skupiają strumień pola. Struktury podobne do sieci we wzroście Laplace'a pojawiają się w wyniku tej koncentracji strumienia. Największy gradient pola występuje na czubkach palców, co sprawia, że są one obszarami najintensywniejszego wzrostu, stąd palce z czasem ulegają stopniowemu wydłużeniu. Jeśli jednocześnie odległości między palcami są znacznie większe niż ich szerokość, można przybliżyć palce cienkimi liniami, rozciągającymi się tylko na długości  (rys. \ref{continuous_to_thin}). To przybliżenie nazywa się modelem cienkiego palca -- zamiast śledzić ciągłą granicę, zakłada się, że wzrost ma miejsce tylko w dyskretnej liczbie punktów -- czubkach palców. Końcówki również mogą się rozgałęziać, dzieląc się na dwa palce potomne.

    %  \begin{figure}[h]
    %    \centering
    %    \includegraphics[width=0.9\textwidth]{figs/continuous_to_thin.png}
    %    \caption {Przejście od problemu ciągłego interfejsu do modelu cienkiego palca. Strzałki wskazują prędkość wzrostu interfejsu.}
    %    \label{continuous_to_thin}
    %  \end{figure}

    %  TODO: zdanie ponizej mozna wycofac imo.
    %  Problem ten można przeanalizować np. za pomocą map konforemnych \cite{loewner1923untersuchungen, gubiec2008fingered}. Posłużymy się tutaj metodą rozwiązania równania Laplace'a poprzez rozwinięcie rozwiązania na szereg Taylora na płaszczyźnie zespolonej \cite{petroff2013bifurcation}, co pozwoli nam wykorzystać metody numeryczne do analizy problemu.


    %\section{Obserwacje i walidacja modelu}\label{chapter:validation}

    %  W pierwszej kolejności uzasadnijmy podejście wyjaśniające ewolucję sieci rzecznych erozją przesiąkającą związaną z odpływem wód gruntowych w źródłach. W 1980 r. motywacją Dunne do poszukiwania nowego opisu rozwoju sieci rzecznej była obserwacja obszaru w Vermont. Na granicy tego obszaru przebiegała droga zatrzymująca lądowy spływ wód, co uniemożliwiłoby rozwój sieci rzecznej pod drogą, gdyby rzeka była zasilana spływem powierzchniowym. Powstała tam jednak sieć rzeczna -- droga leżąca na powierzchni nie blokowała przepływu wód gruntowych \cite{dunne1980formation}. Pięć lat później, w 1985 roku, w Ref.~\cite{laity1985sapping} wykazano, że rzeki na płaskowyżu Kolorado są również zasilane przez wody gruntowe. Ponadto Lobkovsky \cite{lobkovsky2004threshold} wykazał, że spływ powierzchniowy przyczynia się do erozji tylko przy odpowiednio dużym nachyleniu terenu, co znacznie rozszerza zakres stosowalności modelu. Innym czynnikiem, który pozwala nam zaniedbywać spływ powierzchniowy, jest rodzaj gleby, w którą wcinają się rzeki. Przepuszczalny piasek lub porowate skały, takie jak piaskowiec, pozwalają wodzie opadać pod ziemię i gromadzić się w warstwie wodonośnej.

    %  Następnie, aby zweryfikować podejście oparte na modelu cienkich palców, Seybold et al. w Ref.~\cite{seybold2017climate, seybold2018branching} wykonali analizę statystyczną rzek rosnących na obszarach o różnej wilgotności i wykazali związek między klimatem a średnim kątem rozwidlenia w sieci. Można analitycznie wykazać, że kąt rozwarcia bifurkacji w modelu cienkiego palca wynosi $72^\circ$ \cite{hastings2001growth, carleson2002laplacian, gubiec2008fingered, devauchelle2012ramification} i widzimy, że ten kąt odpowiada obszarom wilgotnym na Rys.~\ref{klimat_katy}. Można to wytłumaczyć tym, że woda zwykle spływa po suchej glebie (np. na pustyniach), podczas gdy w wilgotnych regionach może łatwiej zapadać się w ziemię.

    %  \begin{figure}[H]
    %    % \vspace{-15pt}
    %    \centering
    %    \includegraphics[width=0.45\textwidth]{figs/klimat_katy.png}
    %    % \vspace{-15pt}
    %    \caption{Porównanie średnich kątów rozgałęzień w sieciach rzecznych (a) z wilgotnością regionu (AI -- wskaźnik suchości) (b)}
    %    % \vspace{-5pt}
    %    \label{klimat_katy}
    %  \end{figure}

    %  Przykładami sieci rzecznych rozwijających się na polu Laplace'a są rzeki rosnące na wybrzeżu Nowej Zelandii \cite{schumm1986composite}. Zaopatrywane są w wodę z topniejących lodowców górskich, która następnie opada w ziemię i transportowana jest na duże odległości w zbiornikach wód podziemnych. Rys.~\ref{nowa_zelandia} pokazuje podobieństwo rzek w takim układzie do palców sięgających w kierunku odległego źródła wody TODO: remove this and add reference to stasiek work: uzyskanych w symulacjach.

    %  \begin{figure}[h]
    %    \centering
    %    \includegraphics[width=1\textwidth]{figs/nowa_zelandia.png}
    %    \caption{Rzeki rosnące na polu Laplace'a na wybrzeżu Nowej Zelandii \cite{schumm1986composite}}
    %    \label{nowa_zelandia}
    %    \vspace{0pt}
    %  \end{figure}

    %  Większość rzek jest jednak zasilana przez lokalne opady. Przykładem tego typu sieci ewoluującej w polu Poissona jest sieć dopływów rzeki Apalachicola na Florydzie \cite{schumm1995ground}. Dla tej sieci rzecznej przeprowadzono szereg analiz w celu potwierdzenia stosowalności modelu wód podziemnych. W ref. \cite{petroff2013bifurcation} Petroff i in. zmierzyli kąty z 4966 bifurkacji i wykazali, że średni kąt $\alpha = 71,9^\circ \pm 0.8^\circ$, co jest bardzo zgodne z teoretyczną wartością $2\pi/5=72^\circ$ (rys. .~\ref{apalachicola_katy}). Dodatkowo rozwiązali numerycznie równanie Poissona dla fragmentu tej sieci, co przedstawiono na rys.~\ref{potencjal_floryda}a. Wykorzystując wyliczony potencjał uzyskali strumień wody na całym rozpatrywanym obszarze. Następnie zmierzono doświadczalnie strumień wody płynącej w rzekach, a porównanie teorii z eksperymentem przedstawiono na rys.~\ref{potencjal_floryda}b. Ponownie dane teoretyczne i eksperymentalne wykazują wysoki stopień zgodności.

    %  \begin{figure}[H]
    %    \centering
    %    \begin{minipage}{0.4\textwidth}
    %      \caption{Rozkład kątów bifurkacji oszacowany na podstawie 4966 cieków rozwidlonych w sieci rzecznej Apalachicola.}
    %      \label{apalachicola_katy}
    %    \end{minipage}
    %    \hspace{20pt}
    %    \begin{minipage}{0.5\textwidth}
    %      \centering
    %      \includegraphics[width=1\textwidth]{figs/florida_angles.png}
    %      \end{minipage}
    % \end{figure}  

    % \begin{figure}[H]
    %   \centering
    %   \includegraphics[width=\textwidth]{figs/potencjal_floryda_przewidywania.png}
    %   \caption{Zwierciadło wód gruntowych i związany z nim przepływ wód gruntowych w sieci na Florydzie \cite{petroff2011geometry}. (a)~Wielkość obliczonego pola Poissona (b)~Porównanie przewidywanego zrzutu z pomiarami w 30 punktach sieci wykonanych w styczniu 2009 (punkty niebieskie) i 52 punktach w kwietniu 2009 (punkty czerwone). Czarna linia oznacza równość. To porównanie jest bezpośrednie i nie wymaga regulowanych parametrów.}
    %   \label{potencjal_floryda}
    % \end{figure}

  \section{Rozwiązywanie równania Laplace'a}\label{chapter:solving}
    
    We współrzędnych biegunowych (gdzie kierunek stycznej do palca na wierzchołku ustawia $\theta = 0$) pole w pobliżu wierzchołka można rozszerzyć \cite{derrida1992needle , petroff2013bifurcation}:
    
    \begin{equation}\label{phi_polar}
      \phi(r,\theta)=a_1r^{1/2}\cos\frac{\theta}{2}+a_2r \sin \theta+a_3 r^{3/2} \cos\frac{3\theta}{2}+\mathcal{O}\left(r^2\right) \,,
    \end{equation}

    Równ. \eqref{phi_polar} obowiązuje również w przypadku pól Poissona, ponieważ w sąsiedztwie wierzchołka wkład strumienia z członu źródłowego jest pomijalny w porównaniu do strumienia z obszarów oddalonych od wierzchołka. Dla każdego z wiodących współczynników $a_i$ w równaniu \eqref{phi_polar} możemy znaleźć interpretację fizyczną.

    Po pierwsze, współczynnik $a_1$ jest powiązany z całkowitym strumieniem na małym okręgu o promieniu $r_0$ wokół końcówki:
    
    \begin{equation}\label{circle}
      J|_{r_0} = \oint_{r_0} (-\kappa \nabla \phi) \cdot \hat{n} \ \textrm{d}l = 2 \kappa a_1 r_0^{1/2} + \mathcal{O}\left(r_0^{3/2}\right) \,.
    \end{equation}

    Współczynnik $a_2$ jest powiązany z asymetrią pola wokół wierzchołka. Przy dodatnim $a_2$ strumień pola jest większy po prawej stronie wierzchołka, a przy ujemnym $a_2$ — po lewej stronie. Palec rośnie jednak w kierunku największego strumienia i w efekcie rośnie w taki sposób, że $a_2$ zawsze znika (zasada lokalnej symetrii \cite{cohen2015path}).
    
    Wreszcie $a_3$ jest połączona z drugą pochodną pola. Jeśli ponownie skupimy się na małym okręgu o promieniu $r_0$ wokół końcówki i zbadamy pole jako funkcję kąta $\theta$, zauważymy, że przy ustalonych $a_1>0$ i $a_2=a_3=0$ pole ma pojedyncze maksimum przy $\theta = 0$. Im mniejszy współczynnik $a_3$, tym bardziej płaskie maksimum pola wokół końcówki. W końcu, gdy druga pochodna $\phi$ znika, co odpowiada ujemnej wartości $a_3/a_1$:
    
    \begin{equation}\label{a3a1}
      \frac{\partial^2 \phi}{\partial \theta^2}\big|_{\theta=0, r=r_0} = 0 \implies a_3/a_1 = -\frac{1}{9 r_0} \,, 
    \end{equation}
    
    to pojedyncze maksimum przekształca się w dwa maksima w $\pm \theta_0$. Zauważ, że wartość progowa $a_3/a_1$ zależy od odległości $r_0$ od końcówki, przy której analizowane jest pole. Dla nieskończenie małych $r_0$ profil pola jest zawsze symetryczny z jednym maksimum przy $\theta=0$.

    Aby otrzymać współczynniki $a_i$, możemy po prostu rozwiązać odpowiednie równanie dla pola (Laplace'a lub Poissona) metodą elementów skończonych, a następnie korzystając z postaci całkowej współczynników:
    
    \begin{equation}
      \label{a1}
      a_1 = \frac{1}{\pi r_0^{1/2}}\int^{\pi}_{-\pi} \phi(r_0,\theta)\cos\frac{\theta}{2}\textrm{d}\theta \,,
    \end{equation} 
    
    \begin{equation}
      \label{a2}
      a_2 = \frac{1}{\pi r_0}\int^{\pi}_{-\pi} \phi(r_0,\theta)\sin\theta \textrm{d}\theta \,,
    \end{equation}
    
    \begin{equation}
      \label{a3}
      a_3 = \frac{1}{\pi r_0^{3/2}}\int^{\pi}_{-\pi} \phi(r_0,\theta)\cos\frac{3\theta}{2}\textrm{d}\theta
    \end{equation}	
    
    %obliczyć je. Przeprowadzamy ją w programie RiverSim który był inspirowany rozwiązaniem w FreeFEM++\cite{hecht2012new} początkowo stworzonych przez grupę Daniela Rothmana w MIT \cite{petroff2011geometry, petroff2013bifurcation, cohen2015path} i dalej rozwijanych w grupie Piotra Szymczaka \cite{morawiecki2016problem, zukowski2019zwiazek}.



  \section{Ewolucja sieci rzecznej}
    
    %\subsection{Reguły wzrostu}

    W najogólniejszym przypadku prędkość wzrostu może być dowolną funkcją pola ($v = f(\phi)$), ale w klasycznym wzroście Laplace'a jest proporcjonalna do gradientu pola -- $f(\phi) = \alpha |\nabla \phi|$, gdzie $\alpha$ jest stałą proporcjonalności. Jednak, prawo potęgowe zostały odnotowane w wielu różnych systemach fizycznych, np. przebicie dielektryczne \cite{niemeyer1984fractal} i -- po tych pracach -- założymy tutaj, że prędkość końcówki jest proporcjonalna do strumienia wchodzącego w nią pola ($J$) do potęgi $\eta$. Przypominając równanie \eqref{circle} mamy \cite{carleson2002laplacian, selander1999two}:
       
    \begin{equation}\label{velocity}
      v = \alpha a_1^\eta \,.
    \end{equation}
      
    W literaturze dotyczącej modelu cienkiego palca stosuje się dwa różne deterministyczne kryteria podziału -- kryterium prędkości i kryterium kształtu pola. Pierwsze kryterium może być wprost zaimplementowane w modelu cienkiego palca jako próg $a_1$: $a_1 > a_1^c$.

    Drugie kryterium jest związane z ekstremami strumienia (w funkcji kąta biegunowego) \cite{petroff2013bifurcation, kaandorp2001algorithmic_Chapter4.4}, a więc ze współczynnikiem $a_3$. Gdy dla danego promienia $r_0$ strumień pola ma wysokie pojedyncze maksimum, palec rośnie w kierunku tego maksimum. Jeśli jednak strumień pola z boków wierzchołka staje się porównywalny do tego z przodu, a nawet w końcu staje się większy (co odpowiada pojawieniu się dwóch maksimów przy $\pm \theta_0$), palec próbuje rosnąć w dwóch kierunkach jednocześnie, co skutkuje bifurkacją. Mówiąc dokładniej, mówimy, że palec dzieli się, gdy $a_3/a_1$ jest mniejsze niż jakaś wartość krytyczna.

    %\begin{figure}[H]
    %  \centering
    %  \includegraphics[width=0.4\textwidth]{figs/bifurcation_rule_a3.png}
    %  \caption{Kryterium kształtu pola bifurkacji: $a_3/a_1 < \textrm{wartość krytyczna} $. Na działce linie pola wchodzące w okrąg wokół czubka z dwóch stron.} 
    %  \label{bif_rule_a3}
    %\end{figure}

  \chapter{Rozwiązanie numeryczne i struktura oprogramowania}

    \hspace{1em} \= 
    Pole wód podziemnych kształtuję erozje w oklicy żródła i jak skutek dynamikę i rozwój sięci. Z matematycznego modelu dla opisu sieci rzecznych otrzymujemy równania dla opisu wód podziemnych w postaci równania Laplacea \ref{laplace}(lub Poissona \ref{poisson}). Pole w okolicy źródła jest aproxymowane współcznynnikami $a_i$ (\ref{a1} \ref{a2} \ref{a3}). Całkowanie współcznynników jak i rozwiązywanie też w swoją kolej wymaga metod numerycznych. W ogólnym przypadku równanie Laplace można rozwiązać metodami numerycznymi, a w szczegolności w tej pracy skorzystano z metody skończonych elementów. \\ \indent
    %В попередніх проектах вже було представлені рішення для задачі еволюції мережі річки. Один з розв'язків був написаний з використанням Фреефем++ і Матлаб. Інший, з допомогою конформних перетворень. Однак для отримання і ще більших мереж річок потрібен був оптимальніший розв'язок. Другою вимогою було використання тільки технологій із відкритим вихідним кодом, адже не кожен має можливість придбати Матлаб. Вибір припав на C++\cite{Stroustrup1997} та Python. Адже ці мови програмування є одними з найбілш росповсюдженних, а також містять в собі багато бібліотек із відкритим кодом, що полегшує написання програм. C++ -- з одного боку, він дуже швидкий, але вимогливий до написання. С++ містить реалізацію частини програми, яка займає є складною в обчисленнях, такі як алгоритми для роботи із геометрією, генерацією сітки, розязок диференціальних рівняннь. Python\cite{python3} -- має меншу обчислювальну ефективність, але набагато швидший у розробці програмного забезпечення і надає інтерактивний інструмент для написання скрипту -- Jupyter.  
    W poprzednich projektach prezentowano już rozwiązania problemu ewolucji sieci rzecznej. Jedno z rozwiązań zostało napisane przy użyciu Freefem++ i Matlaba. Inny, za pomocą przekształceń konforemnych. Jednak aby uzyskać jeszcze większe sieci rzeczne, potrzebne było bardziej optymalne rozwiązanie. Drugim wymogiem było korzystanie wyłącznie z technologii z otwartym kodem źródłowym, ponieważ nie każdy ma możliwość zakupu Matlaba. Wybór padł na C++\cite{Stroustrup1997} i Python\cite{python3}. W końcu te języki programowania należą do najbardziej rozpowszechnionych, a także zawierają wiele bibliotek z otwartym źródłołem kodem, co ułatwia pisanie programów. C++ -- z jednej strony jest bardzo szybki, ale wymagający w pisaniu. C++ zawiera implementację części programu, która jest złożona w obliczeniach, takich jak algorytmy pracy z geometrią, generowanie siatki i rozwiązywanie równań różniczkowych. Python — ma mniejszą wydajność obliczeniową, ale jest znacznie szybszy w tworzeniu oprogramowania i zapewnia interaktywne narzędzie do tworzenia skryptów — Jupyter.

    \begin{figure}[H]
      \centering
      \includegraphics[width=1\textwidth]{figs/ProgramWorkflowMainIllustration.png}
      %(1) Початкова геометрія, задавання місць на границі звідки буде рости річка, граничні умови. (2) Початкова мережа річки(можна не задавати). (3) Спрощення геометрії річки. (4) Генерація дрібнозернистого мешу. (5) Розв'язок диференційних рівнянь. (6) Визначення параметрів ряду довкола джерел. (2) Ріст мережі річки.
      %Метод конечних елементів вимагає визначення геометрії області, потім її дискретизація, створення лінійних рівнянь, розв’язування рівнянь, інтегрування коефіцієнти $a_i$ розкладу в ряд. Наведені вище кроки формують структуру програмного забезпечення \ref{program_workflow}.
      \caption {Metoda elementów skończonych wymaga wyznaczenia geometrii obszaru, następnie jej dyskretyzacji, utworzenia równań liniowych, rozwiązania równań, zintegrowania współczynników rozszerzenia $a_i$ w szereg. Powyższe kroki tworzą strukturę oprogramowania. (1) Geometria początkowa, ustalenie miejsc na granicy, z których rzeka będzie wypływać i warunki brzegowe. (2) Początkowa sieć rzeki (opcjonalnie). (3) Uproszczenie geometrii rzeki. (4) Generowanie drobnoziarnistej siatki. (5) Rozwiązywanie równań różniczkowych. (6) Wyznaczanie parametrów szeregu wokół źródeł. (2) Wzrost sieci rzecznej.}
      \label{program_workflow}
    \end{figure}
      
    W trakcie tworzenia oprogramowania było stworzono dwa rzowiązania: RiverSim\cite{riversim} - program który zawiera wszystkie algorytmy dla generacji sieci rzecznych, riversimpy\cite{riversimpy} - biblioteka w Pythonie które zawiera algorytmy ułatwiające tworzenie skryptów dla symulacji wzrostu sieci w polu Laplasowskim. 
    RiverSim zawiera niektórę dodatkowe algorytmy dla odwracalnej ewolucji wsztecznej i do przodu, a poza tym RiverSim i riversimpy zawierają tę same algorytmy, w podalszym opisie głównie skupimysię na riversimpy. 

    \section{Geometria}
      
      % В реальних середовищах еволюції русла річок даного типу, ми можемо зустріти цілий ряд чинників, котрі мають вплив на поле підземних вод. Наприклад, це можуть бути гори звідки регулярно надходить потік води, озеро котре може слугувати кінцевою точкою або початком річки. Мережа річки теж має вплив на поле підземних вод і багато інших чинників. Ця довільність геометрії продемонстрована на малюнку \ref{geometry_examples}.
      W rzeczywistych środowiskach ewolucji koryt rzecznych możemy napotkać szereg czynników, które mają wpływ na pole wód gruntowych. Na przykład mogą to być góry, z których regularnie wypływa strumień wody, jezioro, które może służyć jako punkt końcowy lub początek rzeki. Sieć rzeczna ma również wpływ na pole wód gruntowych i wiele innych czynników. Ta arbitralność geometrii jest pokazana na rysunku \ref{geometry_examples}.
      
      \begin{figure}[H]
        \centering
        \includegraphics[width=1\textwidth]{figs/geometry_examples.png}
        \caption {Szereg przykładów granicy:  prostokąt (1),  basen rzeki aproksymoway łamą linią (2), granica zawierająca granicę(3), brzegi nie powiązane topologicznie (4), sieć rzeki (5).}
        \label{geometry_examples}
      \end{figure}
      
      %І що б охопити всю цю довільність геометрії, було створено цілий ряд класів і функцій. Деякі найголовніші класи і функції: Point, Polar, Line, Boundary, BoundaryConditions, Sources, Branch, Rivers, Region і функція BoundaryGenerator. Приклади використання даних функцій розглянемо далі.
      Aby pokryć całą tę arbitralność geometrii, stworzono szereg klas i funkcji\ref{GeometryClasses}. Niektóre z najważniejszych klas i funkcji to Point, Polar, Line, Boundary, BoundaryConditions, Sources, Branch, Rivers, Region i funkcja BoundaryGenerator. Poniżej rozważymy przykłady użycia tych funkcji.
      
      \begin{figure}[H]
        \centering
        \includegraphics[width=0.9\textwidth]{figs/GeometryClasses.png}
        \caption {TODO.}
        \label{GeometryClasses}
      \end{figure}

      \begin{figure}[H]
        \centering
        \includegraphics[width=0.9\textwidth]{figs/region_workflow.png}
        \caption {TODO.}
        \label{region_workflow}
      \end{figure}

      %Спочатку задаємо впорядковану множину координат з допомогою класу Point і ліній з допомогою класу Line для визначення границі. В програмі границя репрезентується класом Boundary. Таких границь може бути декілька. Група границь котрим присвоєний унікальний індекс утворює регіон який репрезентується класом Region. Границя - це замкнута лінія, іншими словами полігон. В регіоні немає обмежень на кількість границь. Границя також може містити цілковито іншу границю, проте перетин ліній не допускається. Щоб утворити дірку в границі потрібно визначити координату в межах цієї границі і присвоїти до списку дір який зберігається в класі Region. Наступним кроком є визначення місць звідки буде відбуватися ріст мережі річки. Такими місцями може бути кожна  точка границі і джерел може бути необмежена кількість(практично обмежена сумарної кількістю координат границь). Для зберігання інформації про початкові координати джерел створено клас Source. Цей клас зберігає унікальний номер кожного джерела, номер границі на котрій розташовується і номер координати на даній границі.
      Najpierw określamy uporządkowany zestaw współrzędnych za pomocą klasy Point i linii za pomocą klasy Line, aby określić granicę. W programie granica jest reprezentowana przez klasę Boundary. Takich granic może być kilka. Grupa granic, którym przypisano unikalny indeks, tworzy region reprezentowany przez klasę Region. Granica jest zamkniętą linią, innymi słowy wielokątem. W regionie nie ma ograniczeń co do liczby granic. Jedna granica może również zawierać inną granicę, ale przecięcie linii jest niedozwolone. Aby utworzyć otwór w granicy, należy zdefiniować współrzędną w obrębie tej granicy i przypisać ją do listy otworów przechowywanej w klasie Region. Kolejnym krokiem jest określenie miejsc, z których nastąpi rozwój sieci rzecznej. Takimi miejscami może być każdy punkt granicy, a źródeł może być nieograniczona (praktycznie ograniczona całkowitą liczbą współrzędnych granic). Klasa Source została stworzona do przechowywania informacji o początkowych współrzędnych źródeł. Ta klasa przechowuje unikalny numer każdego źródła, numer granicy, na której się znajduje, oraz numer współrzędnej na tej granicy.

      \begin{mintedbox}{python}
        from riversim import *

        outer_boundary = Boundary()
        outer_boundary.vertices.extend([Point(0.13, 0.011), Point(0.31, 0), Point(0.74, 0.15), Point(0.95, 0.35), Point(0.8, 0.75), Point(0.47, 0.85), Point(0.152, 0.76), Point(0, 0.5), Point(0.025, 0.3)])
        outer_boundary.lines.extend([Line(0, 1, 1), Line(1, 2, 1), Line(2, 3, 1), Line(3, 4, 1), Line(4, 5, 2), Line(5, 6, 2), Line(6, 7, 1), Line(7, 8, 1), Line(8, 0, 1)])

        inner_boundary = Boundary()
        inner_boundary.vertices.extend([Point(0.3, 0.7), Point(0.5, 0.76), Point(0.65, 0.7), Point(0.66, 0.59)])
        inner_boundary.lines.extend([Line(0, 1, 1), Line(1, 2, 3), Line(2, 3, 3), Line(3, 0, 1)])

        region = Region()
        region[1] = outer_boundary; region[2] = inner_boundary
        region.holes.append(Point(0.4, 0.7))

        sources = Sources()
        sources[1] = t_source_coord(1, 1) 
        sources[2] = t_source_coord(1, 8) 
        sources[3] = t_source_coord(2, 3)\end{mintedbox}

      %Після визначення регіону і розташування джерел, тепер можемо перейти до побудови геометрії річки. Всі дані про геометрію річок і алгоритми містяться в класі Rivers. Rivers містить унікальний номер для кожної річки, котрий має теж саме значення,  що й номер джерела в Sources. Для ініціалізації класу Rivers, потрібно конвертувати дані з класу Sources в координати і напрямок. Для цього служить функція GetSourcesIdsPointsAndAngles класу Region аргументом котрої є Sources. В результаті ми отримаємо набір індексів річок і відповідні їм координати і напрямок перпендикулярний до границі. Для визначення точного напрямку перпендикуляру, має значення напрямок координати при задаванні границі. Прийнято, що перпендикуляр буде з лівої сторони від напрямку координат. Тому якщо звернути увагу на регіон де є дірка по центрі, то зовнішня границя має протилежний напрямок нумерації координат відносно внутрішньої.
      Po określeniu regionu i lokalizacji źródeł możemy przystąpić do konstruowania geometrii rzeki. Wszystkie dane geometrii rzeki i algorytmy są zawarte w klasie Rivers. Rzeki zawierają unikalny numer dla każdej rzeki, który ma takie samo znaczenie jak numer źródła w Źródłach. Aby zainicjować klasę Rivers, należy przekonwertować dane z klasy Sources na współrzędne i kierunek. W tym celu jako argument służy funkcja GetSourcesIdsPointsAndAngles klasy Region, której argumentem jest Sources. W rezultacie otrzymamy zestaw indeksów rzecznych i odpowiadających im współrzędnych oraz kierunek prostopadły do granicy. Aby określić dokładny kierunek prostopadłej, podczas wyznaczania granicy ważny jest kierunek współrzędnych. Zakłada się, że prostopadła będzie po lewej stronie kierunku współrzędnych. Dlatego jeśli zwrócisz uwagę na obszar, w którym znajduje się dziura w środku, wówczas zewnętrzna granica ma przeciwny kierunek numeracji współrzędnych w stosunku do wewnętrznej.
      
      \begin{figure}[H]
        \centering
        \includegraphics[width=0.6\textwidth]{figs/rivers_initialization.png}        
        \caption {TODO.}
        \label{rivers_initialization}
      \end{figure}

      \begin{mintedbox}{python}
        rivers = Rivers()
        rivers.initialize(region.getSourcesIdsPointsAndAngles(sources))\end{mintedbox}
      
        %Вище вказувалося, що в більшості випадків біфуркація річки відбувається на дві частини. А якщо поділів відбувається більше, ми можемо вважати це двома послідовними достатньо близько розташованими між собою біфуркаціями. Поміж біфуркаціями річка апроксимується ламаною лінією. Інформація  про цю лінію криється в класі Branch. А інформація про те котрі частини річки з'єднуються з іншими частинами річки в пунктах біфуркації міститься в графі котрий в свою чергу міститься в класі Rivers. Класс Rivers надає можливості для легкого способу працювати із геометрією річки, а саме: отримання інформації про поточний стан річок(довжини, відношення між частинами річками, визначення кривизни, координати джерел і тд), розвиток мережі річки(додавання нових координат до річки при рості, згладжування кривизни, створення нових річок, додавання нових пунктів біфуркації), зменшення довжини річки і  видалення пунктів біфуркації для полегшення обрахунків при оберненій еволюції. 
      Powyżej zaznaczono, że w większości przypadków rzeka rozdziela się na dwie części. A jeśli podziałów jest więcej, możemy to uznać za dwa kolejne bifurkacje dostatecznie blisko siebie. Pomiędzy punktami bifurkacji rzeka jest aproksymowana linią przerywaną. Informacje o tej linii znajdują się w klasie Branch. A informacja o tym, które odcinki rzeki łączą się z innymi odcinkami rzeki w punktach rozwidlenia, zawarta jest w grafie, który z kolei jest zawarty w klasie Rivers. Klasa Rivers daje możliwość łatwej pracy z geometrią rzek, a mianowicie: uzyskiwania informacji o aktualnym stanie rzek (długości, relacje między odcinkami rzek, określanie krzywizny, współrzędne źródeł itp.), opracowywania sieci rzecznej ( dodawanie nowych współrzędnych do rzeki podczas wzrostu, wygładzanie krzywizny, tworzenie nowych rzek, dodawanie nowych punktów bifurkacji), zmniejszanie długości rzeki i usuwanie punktów bifurkacji w celu ułatwienia obliczeń podczas ewolucji odwrotnej.
      
      \begin{mintedbox}{python}
        rivers_ids = t_sources_ids(); rivers_ids.extend([1, 2, 3])
        ds = 0.01
        tip_points = t_PolarList(); tip_points.extend([Polar(ds, 0), Polar(ds, 0), Polar(ds, 0)])
        boundaries_ids = t_boundaries_ids(); boundaries_ids.extend([1, 2, 1])
        rivers.addPolars(rivers_ids, tip_points, boundaries_ids)
      
        sub_branch_ids = rivers.createSubBranches(1, -3.1415/5, 3.1415/5)\end{mintedbox}

      %Оскільки мережа річки котра міститься в класі Rivers опирається в своїй реалізації на клас Boundary, то для кожного сегменту річки ми можемо задати унікальні граничні умови. Наприклад, можна врахувати "опір" русла ріки і збільшення висоти підземних вод вздовж.
      Ponieważ sieć rzeczna zawarta w klasie Rivers opiera się w swojej implementacji na klasie Boundary, możemy ustawić unikalne warunki brzegowe dla każdego odcinka rzeki. Naprzykład, możemy uwzględnić „opór” koryta rzeki i wzrost wysokości wód gruntowych wzdłuż niego.

      \begin{figure}[H]
        \centering
        \includegraphics[width=0.9\textwidth]{figs/tree_coarsening.png}        
        \caption {TODO.}
        \label{tree_coarsening}
      \end{figure}

      \begin{wrapfigure}{r}{0.5\textwidth}
        \begin{center}
          \vspace{-20pt}
          \includegraphics[width=0.45\textwidth]{figs/descritization_reducing.jpg}
        \end{center}
        \caption {Ilustracja algorytmu wygładzenie brzegu.}
        \label{descritization_reducing}
      \end{wrapfigure}

      %Кількість елементів сітки на котру ми розділюємо регіон має прямий вплив на розмір матриці лінійних рівняння, а тому на час знаходження розв'язку диференційного рівняння. Щоб зменшити час обчистленнь, ми можемо зменшити густини координат границі річки, при цьому не втрачаючи на точності. Для цього ми робимо процедуру огрублення границь частин річки. Тепер нам потрібно класи  Sources, Region та Rivers вкласти в границю Boundary, оскільки генератор сітки вимагає тільки  границю як аргумент. Другою проблемою, котра згадувалася вище є те, що немає можливості задати граничні умови в середині регіону, а тільки на границі. Для цього лінії з котрих складається мережа річки розділяються на дві лінії котрі знаходяться дуже близько одна до одної.
      Liczba elementów siatki, na jakie dzielimy obszar, ma bezpośredni wpływ na wielkość macierzy równań liniowych, a więc na czas znalezienia rozwiązania równania różniczkowego. Aby skrócić czas obliczeń, możemy zmniejszyć gęstość współrzędnych granicy rzeki bez utraty dokładności. Zmniejszenie zagęszczenia współrzędnych na granicy opiera się na następującej idei: każda kolejna współrzędna zmienia kierunek linii o pewien kąt. Jeśli kąt jest bardzo mały, możemy założyć, że współrzędne leżą praktycznie na tej samej linii. Dlatego możemy usunąć wszystkie współrzędne pośrednie i pozostawić tylko te skrajne. Aby znaleźć „skrajne” współrzędne linii, iterujemy po wszystkich współrzędnych i obliczamy całkowity kąt odchylenia, gdy tylko ten kąt stanie się większy niż wartość krytyczna, traktujemy tę współrzędną jako skrajną.

    \section{Generacja siatki}

      \begin{figure}[H]
        \centering
        \includegraphics[width=0.9\textwidth]{figs/mesh_generation.png}        
        \caption {TODO.}
        \label{mesh_generation}
      \end{figure}

      %Для генерації сітки нам потрібна замкнута границя Boundary. Для цього існує функція BoundaryGenerator, котра об'єднує класи  Sources, Region та Rivers в одну границю Boundary. Другою проблемою, котра згадувалася вище є те, що немає можливості задати граничні умови в середині регіону, а тільки на границі. Для цього лінії з котрих складається мережа річки розділяються на дві лінії котрі знаходяться достатньо близько одна до одної.
      Aby wygenerować siatkę, potrzebujemy zamkniętej granicy Boundary. W tym celu dostępna jest funkcja BoundaryGenerator, która łączy klasy Sources, Region i Rivers w jedną granicę Boundary. Drugi problem, o którym była mowa powyżej, polega na tym, że nie ma możliwości ustalenia warunków brzegowych w środku regionu, a jedynie na granicy. W tym celu linie tworzące sieć rzeczną są podzielone na dwie linie, które są wystarczająco blisko siebie.

      \begin{mintedbox}{python}
        region_params = RegionParams()
        region_params.smoothness_degree = 0.2
        region_params.river_width = 1e-8
        boundary = BoundaryGenerator(sources, region, rivers, region_params)\end{mintedbox}

      %Коли є замкнута границя можна згенерувати сітку. Для цього була використана C++ бібліотека \cite{szewczuk1996triangle}. Методи і алгоритми бібліотеки Traingle містяться в однойменному класі. Triangle генерує Деланау сітку. Triangle дає можливість задати значення мінімального кута трикутника, мінімальної і максимальної довжини сторони трикутника, мінімальної і максимальної площі трикутника, співвідношення сторін трикутника та інше. Другим важливим аспектом є генерація достатньо малої сітки в місцях, де поле підземних вод змінюється найшвидше -- довкола джерел. Для цього можна задати множину координат(а саме координат джерел), де буде обмежена радіально площа трикутника відносно даних точок. Функція котра обмежує площу трикутника виглядає наступним чином:
      Gdy istnieje zamknięta granica, można wygenerować siatkę. W tym celu wykorzystano bibliotekę C++ Triangle\cite{szewczuk1996triangle}. Metody i algorytmy biblioteki Traingle są zawarte w klasie o tej samej nazwie. Trójkąt generuje siatkę Delaunaya. Trójkąt pozwala ustawić wartość minimalnego kąta trójkąta, minimalną i maksymalną długość boku trójkąta, minimalną i maksymalną powierzchnię trójkąta, stosunek boków trójkąta itp. Drugim ważnym aspektem jest generowanie odpowiednio małej siatki w miejscach, w których pole wód podziemnych zmienia się najszybciej - w okolicach źródeł. Aby to zrobić, możesz określić zestaw współrzędnych (czyli współrzędne źródeł), w których obszar trójkąta względem danych punktów będzie ograniczony promieniowo. Funkcja ograniczająca pole trójkąta wygląda następująco:
      \begin{equation}
        f(x) = x^{2}
      \end{equation}

      %Розв'язувач Deal.II\cite{dealII94} вимагає сітки із квадратними елементами. Для цього ми використовуємо бібліотеку C++  Tethex \cite{tethex}  котра конвертує трикутні елементи сітки у чотирикутники, розбиваючи один трикутний елемент на три квадратних, чим збільшуючи кількість елементів сітки у три рази.
      Solver Deal.II\cite{dealII94} wymaga siatki z elementami kwadratowymi. W tym celu używamy biblioteki Tethex \cite{tethex} C++, która konwertuje trójkątne elementy siatki na czworoboki, dzieląc jeden trójkątny element na trzy kwadratowe, zwiększając w ten sposób liczbę elementów siatki trzykrotnie.

      \begin{mintedbox}{python}
        mesh_params = MeshParams()
        mesh_params.max_area = 1e6
        mesh_params.min_area = 6e-7
        mesh_params.max_edge = 1
        mesh_params.min_edge = 8e-12
        mesh_params.ratio = 2.3
        mesh_params.refinment_radius = 5e-3
        mesh_params.exponant = 1
        mesh_params.sigma = 1.9
      
        triangle = Triangle(mesh_params)
        triangle.mesh_params.tip_points = rivers.TipPoints()
        mesh = triangle.generate(boundary, region.holes)\end{mintedbox}

    \section{Warunki brzegowe}

      %Кожна лінія містить також номер(посилання) граничної умови. Boundaries -- клас котрий містить набір пар із унікальним номером і відповідною йому граничною умовою котра може бути двох типів: Діріхлет і Ноймана. Граничну умову можна задати тільки на граничній лінії, іншими словами задати лінію посеред регіону і граничну умову на ній не можна. Проте лінію завжди можна апроксимувати дуже тонким прямокутником, тож за потреби це не є проблемою.
      Każda linia zawiera również numer (odniesienie) warunku brzegowego. Boundaries -- klasa zawierająca zbiór par o unikalnym numerze i odpowiadającym mu warunku brzegowym, który może być dwojakiego rodzaju: Dirichlet i Neumann. Warunek brzegowy można ustawić tylko na linii granicznej, innymi słowy, nie można ustawić linii pośrodku regionu i warunku brzegowego na nim. Jednak linię zawsze można przybliżyć bardzo cienkim prostokątem, więc w razie potrzeby nie stanowi to problemu.

      \begin{mintedbox}{python}
        boundary_conditions = BoundaryConditions()
        boundary_conditions[1] = BoundaryCondition(DIRICHLET, 0)
        boundary_conditions[2] = BoundaryCondition(NEUMAN, 0)
        boundary_conditions[3] = BoundaryCondition(NEUMAN, 1)\end{mintedbox}

    \section{Rozwiazanie pola wód podziemnych}

      \begin{figure}[H]
        \centering
        \includegraphics[width=0.9\textwidth]{figs/solver.png}        
        \caption {TODO.}
        \label{solver}
      \end{figure}

      Deal.II\cite{dealII94} to C++ biblioteka  przeznaczona do numerycznego rozwiązywania równań różniczkowych cząstkowych przy użyciu adaptacyjnych elementów skończonych. Wykorzystuje najnowocześniejsze techniki programowania, aby zaoferować nowoczesny interfejs do złożonych struktur danych i algorytmów.

      Rozwiążemy prostą wersję równania Poissona na naszym obszarze z niezerową prawą stroną.
      
      \begin{align*}
        -\Delta \phi &= f \qquad\qquad & \text{in}\ S,
        \\
        \phi &= 0 \qquad\qquad & \text{on}\ \partial S.
      \end{align*}
      
      Rozważymy tylko szczególny przypadek $f(x)=P$.

      Od podstaw metody elementów skończonych wiemy, że potrzebne są kolejne kroki, aby przybliżyć rozwiązanie $\phi$ przybliżeniem skończonych wymiarów. Konkretnie, najpierw musimy wyprowadzić słabą postać powyższego równania, którą otrzymujemy mnożąc równanie przez funkcję testową $u$ z lewej strony i całkując po domenie $S$:
      
      \begin{align*}
        -\int_S u \Delta \phi = \int_S u f.
      \end{align*}
      
      Można to zcałkować przez części:
      
      \begin{align*}
        \int_S \nabla u \cdot \nabla \phi
        -
        \int_{\partial S} u \mathbf{n}\cdot \nabla \phi
         = \int_S u f.
      \end{align*}
      
      Funkcja testowa $u$ musi spełniać ten sam rodzaj warunków brzegowych (w sensie matematycznym: musi pochodzić z przestrzeni stycznej zbioru, w którym szukamy rozwiązania), więc na granicy $u=0$ w konsekwencji otrzymujemy następny wygląd słabej formy:
      
      \begin{align*}
        (\nabla u, \nabla \phi)
         = (u, f),
      \end{align*}

      gdzie zastosowaliśmy powszechną notację $(a,b)=\int_S a\; b$. Następnie problem pyta o funkcję $\phi$, dla której to stwierdzenie jest prawdziwe dla wszystkich funkcji testowych $u$ z odpowiedniej przestrzeni (która tutaj jest przestrzenią $H^1$).

      Oczywiście nie możemy znaleźć takiej funkcji w ogólnym przypadku i zamiast tego szukamy przybliżenia $\phi_h(\mathbf x)=\sum_j \Phi_j u_j(\mathbf x)$, gdzie $\Phi_j$ to nieznane współczynniki rozszerzalności, które musimy wyznaczyć („stopnie swobody” tego problemu), a $u_i(\mathbf x)$ to funkcje kształtu elementów skończonych, których będziemy używać. Aby zdefiniować te funkcje kształtu, potrzebujemy:
      
      \begin{itemize}
        \item Siatka, na której można zdefiniować funkcje kształtu;
        \item Element skończony opisujący funkcje kształtu, których chcemy użyć w komórce odniesienia (kwadrat jednostkowy $[0,1]^2$). Zwykłe funkcje Lagrange'a;
        \item Numeracja wszystkich stopni swobody w siatce;
        \item Odwzorowanie, które mówi, w jaki sposób funkcje kształtu w rzeczywistej komórce są uzyskiwane z funkcji kształtu zdefiniowanych przez klasę elementów skończonych w komórce odniesienia. Domyślnie Deal.II użyje biliniowego mapowania;
      \end{itemize}

      Dzięki tym krokom mamy teraz zbiór funkcji $u_i$ i możemy zdefiniować słabą postać problemu dyskretnego: Znaleźć funkcję $\phi_h$, czyli Znaleźć wspomniane wyżej współczynniki rozszerzalności $\Phi_j$, tak aby

      \begin{align*}
        (\nabla u_i, \nabla \phi_h)
         = (u_i, f),
         \qquad\qquad
         i=0\ldots N-1.
      \end{align*}

      Przestrzegamy tutaj konwencji, że wszystko jest liczone od zera, co jest powszechne w C i C++. To równanie można zapisać jako układ liniowy, jeśli wstawi się reprezentację $\phi_h(\mathbf x)=\sum_j \Phi_j u_j(\mathbf x)$, a następnie zaobserwujemy, że

      \begin{align*}
        (\nabla u_i, \nabla \phi_h)
        &= \left(\nabla u_i, \nabla \Bigl[\sum_j \Phi_j u_j\Bigr]\right)
        \\
        &= \sum_j \left(\nabla u_i, \nabla \left[\Phi_j u_j\right]\right)
        \\
        &= \sum_j \left(\nabla u_i, \nabla u_j \right) \Phi_j.
      \end{align*}

      Ostatecznie otrzymejmy równanie dla przebliżnoego rozwiązania $\Phi$, aby
      
      \begin{align*}
        A \Phi = F,
      \end{align*}
      
      gdzie macierz $A$ i prawa strona $F$ są zdefiniowani jak:

      \begin{align*}
        A_{ij} &= (\nabla u_i, \nabla u_j),
        \\
        F_i &= (u_i, f).
      \end{align*}

      \paragraph{Siatka adaptacyjna}

        \begin{figure}[H]
          \centering
          \includegraphics[width=0.9\textwidth]{figs/adaptive_refinment.png}        
          \caption {TODO.}
          \label{adaptive_refinment}
        \end{figure}

        Istnieje wiele sposobów adaptacyjnego udoskonalania siatek. Podstawowa struktura algorytmu jest zawsze taka sama i składa się z pętli obejmującej następujące kroki:

        \begin{itemize}
          \item Rozwiąż równanie różniczkowe cząstkowe na bieżącej siatce;
          \item Oszacuj błąd w każdej komórce za pomocą pewnego kryterium wskazującego na błąd;
          \item Zaznacz te komórki, które mają duże błędy do udoskonalania, zaznacz te, które mają szczególnie małe błędy do zgrubienia, a resztę zostawiamy;
          \item Podziel lub połącz zaznaczone komórki, aby uzyskać nową siatkę;
        \end{itemize}

        Poza tą strukturą istnieje jednak wiele sposobów osiągnięcia tego celu. Zasadniczo różnią się tym, jak dokładnie generuje się jedną siatkę z poprzedniej. Dla siatki z trójkątów, trójkąt zaznaczony do udoskonalenia jest dzielony na dwie części poprzez wprowadzenie jednej nowej krawędzi od środka najdłuższej krawędzi do przeciwległego wierzchołka. Oczywiście punkt środkowy od najdłuższej krawędzi musi być w jakiś sposób zrównoważony poprzez udoskonalenie komórki po drugiej stronie tej krawędzi (jeśli taka istnieje). Ta metoda nie działa w przypadku czworokątów, a przynajmniej nie jest łatwa. Powodem jest to, że elementy przejściowe utworzone z czworobocznych sąsiadów czworobocznej komórki, która ma zostać udoskonalona, byłyby trójkątami, a tego nie chcemy. W związku z tym podejście do adaptacyjności wybrane w Deal.II polega na wykorzystaniu siatek, w których sąsiednie komórki mogą różnić się poziomem udoskonalenia o jeden. Powoduje to, że węzły na interfejsach komórek należą do jednej strony, ale są niezrównoważone po drugiej. Powszechnym terminem dla nich są „wiszące węzły”. Jeśli udoskonalimy siatkę globalnie, błąd spadnie jako

        \begin{align*}
          \|\nabla(\phi-\phi_h)\|_{S} \le C h_\text{max}^p \| \nabla^{p+1} \phi \|_{S},
        \end{align*}

        gdzie $C$ jest pewną stałą niezależną od $h$ i $\phi$, $p$ jest stopniem wielomianu używanego elementu skończonego, a $h_{max}$ jest średnicą największej komórki. Jeśli więc ważną jest największa komórka, to dlaczego mielibyśmy chcieć, aby siatka była drobna w niektórych częściach domeny, ale nie we wszystkich? Odpowiedź tkwi w spostrzeżeniu, że powyższy wzór nie jest optymalny. W rzeczywistości poniższe wzór jest lepszym oszacowaniem:

        \begin{align*}
          \|\nabla(\phi-\phi_h)\|_{S}^2 \le C \sum_K h_K^{2p} \| \nabla^{p+1} \phi \|^2_K.
        \end{align*}

        (Ponieważ $h_K\le h_\text{max}$, ta formuła natychmiast implikuje poprzednią, jeśli po prostu wyciągniesz rozmiar oczek z sumy.) Ta formuła sugeruje, że nie jest konieczne, aby największa komórka była mała, ale te komórki tak naprawdę potrzebują być małymi, gdzie $\| \nabla^{p+1} \phi \|_K$ jest duże! Innymi słowy: Siatka naprawdę musi być dokładna tylko wtedy, gdy rozwiązanie ma duże zmiany, na co wskazuje $p+1$ pochodna.
        
        Oczywiście to oszacowanie a priori nie jest zbyt przydatne w praktyce, ponieważ nie znamy dokładnego rozwiązania $\phi$, a za tym idzie, że nie możemy obliczyć $\nabla^{p+1} \phi$. Ale możemy obliczyć numeryczne przybliżenia $\nabla^{p+1} \phi$ bazując tylko na dyskretnym rozwiązaniu $\phi_h$.

    \section{Calkowanie parametrow szeregu}
      
      \begin{figure}[H]
        \centering
        \includegraphics[width=0.9\textwidth]{figs/series_params_integration.png}        
        \caption {TODO.}
        \label{series_params_integration}
      \end{figure}

    \section{IO i inne}
    \section{RiverSim}
    \section{pyriversim}

  \chapter{Weryfikacja i walidacja oprogramowania}
    \section{Zbiezność rozwiazania}
    \section{Zbiezność calkowania i porownanie z wynikiem analitycznym}
    \section{Optymalizacja predkosci i dokladności}

  \chapter{Przyklady obliczen}
    \section{Probabilistyczny wzrost rzeki a potegowe prawo.}
    \section{Ewolucja zwrotna}
    \section{Naczynia krwionosne}

  \chapter{Podsumowanie}

  \section*{Acknowledgements}

  \bibliographystyle{unsrt_initials} %ieeetr
  \bibliography{bibliography}

  \appendix

  \chapter{Główna pętla programu}
    
    Instalacja biblioteki riversim w Python3 (tylko Linux).
    
    \begin{mintedbox}{bash} 
      python3 -m pip install riversim\end{mintedbox}
    
    \begin{mintedbox}{python} 
      from riversim import *
      import numpy as np

      m = Model()
      m.InitializeDirichlet()

      solver = Solver(m.solver_params)
      triangle = Triangle(m.mesh_params)
      mesh = TethexMesh()

      dynamic_river_ids = m.rivers.tipBranchesIds()

      for i in range(m.number_of_steps):
          m.boundary = BoundaryGenerator(\
              m.sources, \
              m.region, \
              m.rivers, \
              m.region_params)

          num_of_intersects = NumOfBoundaryIntersection(m.boundary, m.rivers.tipBoundary())
          if num_of_intersects > 0:
              break

          empt_rivers = Rivers()
          empt_source = Sources()
          only_boundary = BoundaryGenerator(empt_source, m.region, empt_rivers, m.region_params)
          distance_to_boundary = DistanceFromPointsToBoundary(only_boundary, m.rivers.tipPoints())
          if distance_to_boundary <= m.integr_params.integration_radius:
              break

          if len(m.boundary.vertices) == 0:
              break 

          # mesh will be refined aroud growing tip points
          tip_points = t_PointList()
          for id in dynamic_river_ids:
              tip_points.append(m.rivers[id].tipPoint())
          triangle.mesh_params.tip_points = tip_points
          mesh = triangle.generate(m.boundary, m.region.holes)
              
          solver.openMesh(mesh)
          for j in range(m.solver_params.adaptive_refinment_steps + 1):
              if j > 0:
                  solver.refineGrid()
              solver.setupSystem()
              solver.assembleSystem(m.boundary_conditions)
              solver.solve()

          id_series_params = t_ids_series_params()
          max_a1 = 0
          for id in dynamic_river_ids:
              tip_point = m.rivers[id].tipPoint()
              tip_angle = m.rivers[id].tipAngle()
              id_series_params[id] = solver.integrate_new(m.integr_params, tip_point, tip_angle)
              if id_series_params[id][0] > max_a1:
                  max_a1 = id_series_params[id][0]

          for id_series_param in id_series_params:
              id = id_series_param.key()
              series_param = id_series_param.data()
              if m.qGrowth(series_param):
                  l = m.rivers[id].lenght()
                  if m.qBifurcate(series_param, l):
                      tip_point = m.rivers[id].tipPoint()
                      tip_angle = m.rivers[id].tipAngle()
                      br_left = Branch(tip_point, tip_angle + m.bifurcation_angle)
                      br_left.addPoint(Polar(m.ds, 0), m.region_params.river_boundary_id)
                      br_right = Branch(tip_point, tip_angle - m.bifurcation_angle)
                      br_right.addPoint(Polar(m.ds, 0), m.region_params.river_boundary_id)
                      ids = m.rivers.addSubBranches(id, br_left, br_right)

                      # add new branches
                      dynamic_river_ids.append(ids.left)
                      dynamic_river_ids.append(ids.right)

                      # and remove parent from growth evaluation
                      for f in range(len(dynamic_river_ids)):
                          if dynamic_river_ids[f] == id:
                              del dynamic_river_ids[f]
                              break
                  else: 
                      m.rivers[id].addPoint(\
                          m.nextPoint(series_param, l, max_a1),\
                          m.region_params.river_boundary_id)
              else:
                  # remove river from growth evaluation
                  for f in range(len(dynamic_river_ids)):
                      if dynamic_river_ids[f] == id:
                          del dynamic_river_ids[f]
                          break

          if debug:
              save(m, "debug " + str(i) + ".json")

          if not dynamic_river_ids:
              break

      \end{mintedbox}

  \chapter{Przykładowe dane wejściowe algorytmu}

\end{document}