\documentclass[]{pracamgr}

\usepackage{tcolorbox} 

\tcbuselibrary{minted,breakable,xparse,skins}
\tcbuselibrary{minted, breakable, xparse, skins}
\definecolor{bg}{gray}{0.95}
\DeclareTCBListing{mintedbox}{O{}m!O{}}{%
  breakable=true,
  listing engine=minted,
  listing only,
  minted language=#2,
  minted style=default,
  minted options={%
    linenos,
    gobble=0,
    breaklines=true,
    breakafter=,,
    fontsize=\small,
    numbersep=8pt,
    #1},
  boxsep=0pt,
  left skip=0pt,
  right skip=0pt,
  left=10pt,
  right=0pt,
  top=3pt,
  bottom=3pt,
  arc=5pt,
  leftrule=0pt,
  rightrule=0pt,
  bottomrule=2pt,
  toprule=2pt,
  colback=bg,
  colframe=white!10,
  enhanced,
  overlay={%
    \begin{tcbclipinterior}
    \fill[white!10!white] (frame.south west) rectangle ([xshift=20pt]frame.north west);
    \end{tcbclipinterior}},
  #3}

\usepackage[utf8]{inputenc}
\usepackage{wrapfig}
\usepackage{graphicx}
\usepackage{subfig}
\usepackage{float}
\usepackage{amsmath}
\usepackage{cite}
\usepackage{listings} %c++ code snippet
\usepackage{xcolor} %c++ code snippet
\lstset { %
    language=C++,
    %backgroundcolor=\color{black!5}, % set backgroundcolor
    basicstyle=\footnotesize,% basic font setting
} %c++ code

\begin{document}
  
  \maketitle

  \begin{abstract}
    %Мережі в натуральний спосіб з'являються повсюдно в природі. Електростатичний розряд між двома зарядженими областями породжує струм котрий утворює мережу каналів. Дерево зростаючи утворює розгалужену мережу гілок для збору сонячної енергії в ефективний спосіб на протязі багатьох років. Також розвиток мережі судин є керований концентрацією кисню в тканині. 
    Sieci naturalnie pojawiają się wszędzie w przyrodzie. Wyładowanie elektrostatyczne między dwoma naładowanymi obszarami generuje prąd, który tworzy sieć kanałów. W miarę wzrostu drzewo tworzy rozległą sieć gałęzi, które efektywnie gromadzą energię słoneczną przez wiele lat. Również rozwój sieci naczyniowej jest kontrolowany przez stężenie tlenu w tkance.\par

    %На цьому етапі вже можна побачити деяку спільну рису між всіма процесами, а саме наявність взаємозалежних поля і матерії на котра переміщається в локальному напрямку максимального поля. Тому багато процесів із розвитку мережі можна звести до одного математичного формалізму. 
    Na tym etapie można już dostrzec pewną wspólną cechę wszystkich procesów, a mianowicie obecność współzależnych pól i materii poruszającej się w lokalnym kierunku maksymalnego pola. Dlatego wiele procesów rozwoju sieci można sprowadzić do jednego formalizmu matematycznego.\par

    %В даній праці ми фокусуємося на створенні Python бібліотеки котра помагає досліджувати розвиток мережі в полі Лапласа на прикладі розвитку мережі річки. Спочатку ми описуємо математичну модель розвитку мережі річки в полі Лапласа. Тоді описуємо бібліотеку riversim, її алгоритми і показуємо простий спосіб застосування програми крок по кроку. Тоді наводимо приклади збіжності розв'язку і покажемо кілька результатів.
    W tej pracy skupiamy się na stworzeniu biblioteki Pythona, która pomaga badać rozwój sieci w polu Laplace'a na przykładzie rozwoju sieci rzecznej. Najpierw opisujemy matematyczny model rozwoju sieci rzecznej w polu Laplace'a. Następnie opisujemy bibliotekę riversim, jej algorytmy i pokazujemy prosty sposób korzystania z programu krok po kroku. Następnie podajemy przykłady zbieżności rozwiązania i pokazujemy kilka wyników.\par

  \end{abstract}

  \tableofcontents

  \chapter{Model teoretyczny}
    
    %Model wzrostu rzeki jest przykładem wzrostu w odpowiedzi na pole dyfuzji. Pole jest połączone z siecią rzeczną za pomocą warunków brzegowych. Taki połączony układ pól i sieci może opisywać wiele innych naturalnych procesów wzrostu, takich jak wyładowania elektryczne \cite{niemeyer1984fractal}, tworzenie naczyń krwionośnych \cite{nguyen2006dynamics}, wzorce rozpuszczania w ośrodkach porowatych \cite{szymczak2011initial} i inne. W przypadku sieci rzecznych pole opisuje wysokość poziomu wód gruntowych.
    Model wzrostu rzeki jest przykładem wzrostu w odpowiedzi na pole dyfuzji. Pole jest połączone z siecią rzeczną za pomocą warunków brzegowych. Taki połączony układ pól i sieci może opisywać wiele innych naturalnych procesów wzrostu, takich jak wyładowania elektryczne \cite{niemeyer1984fractal}, tworzenie naczyń krwionośnych \cite{nguyen2006dynamics}, wzorce rozpuszczania w ośrodkach porowatych \cite{szymczak2011initial} i inne. W przypadku sieci rzecznych pole opisuje wysokość poziomu wód gruntowych.

    %Говорячи про річкові мережі, вода може надходити в річку двома різними шляхами: (i) через поверхневий стік або (ii) через резервуар підземних вод. У першому випадку вода (зазвичай з опадів) не занурюється в землю, а стікає поверхнею прямо в русло (світло-блакитні стрілки на рис. ~\ref{pow_soaking}). Такий сценарій можна спостерігати в районах, де грунт водонепроникний, а опади настільки інтенсивні, що вода не встигає зануритися в землю.
    Jeśli chodzi o sieci rzeczne, woda może wpływać do rzeki na dwa różne sposoby: (i) przez spływ powierzchniowy lub (ii) przez zbiornik wód podziemnych. W pierwszym przypadku woda (zwykle pochodząca z opadów atmosferycznych) nie wsiąka w ziemię, lecz przepływa po powierzchni bezpośrednio do kanału (niebieskie strzałki na ryc. ~\ref{pow_wsiakanie}). Taki scenariusz można zaobserwować na obszarach, gdzie gleba jest nieprzepuszczalna, a opady są tak intensywne, że woda nie ma czasu wsiąknąć w ziemię.

    \begin{figure}[H]
      \centering
      \includegraphics[width=1\textwidth]{figs/basic_river_illustration.png}
      \caption { Dolina rzeki z jeziorem i ich przekrój. Po prawej stronie można widać jak wody podziemne są napędzane przez opady lub naprzykład przez spływ z gór.}
      \label{pow_wsiakanie}
    \end{figure}

    %Однак, якщо ґрунт достатньо проникний, вода може занурюватися в землю, а не стікати вниз (темно-сині стрілки на рис. \ref{float_soaking}). Вода спочатку накопичується в підземній водоймі, а потім під дією гідродинамічного тиску витікає з річкового джерела і берегів. Цей процес утворює ерозію ґрунту в околиці джерела.
    Jeśli jednak gleba jest wystarczająco przepuszczalna, woda może wsiąkać w ziemię, zamiast spływać (ryc. \ref{pow_wsiakanie}). Woda najpierw gromadzi się w podziemnym zbiorniku, a następnie wypływa ze źródła rzeki i brzegów pod wpływem ciśnienia hydrodynamicznego. Proces ten powoduje erozję gleby w pobliżu źródła.

    \begin{wrapfigure}{r}{0.5\textwidth}
      \begin{center}
        \vspace{-20pt}
        \includegraphics[width=0.45\textwidth]{figs/erosion_illustration.png}
      \end{center}
      \vspace{-20pt}
      \caption{Ilustracja wzrostu rzeki poprzez procesy erozyjne zachodzącę w okolicy źródeł.}
      \vspace{0pt}
      \label{zrodlo}
    \end{wrapfigure}

    %Ця ерозія в околиці джерела, котра відбувається в протилежному напрямку до течії відповідає за розширення та роздвоєння річки (біфуркація), загальну еволюцію річкової мережі.
    Ta erozja w pobliżu źródła, która zachodzi w kierunku przeciwnym do nurtu, jest odpowiedzialna za ekspansję i bifurkację rzeki, ogólną ewolucję sieci rzecznej.

    %Перша кількісна модель, що описує еволюцію таких річок, була представлена ​​в 1980 році Данном \cite{dunne1980formation}. Більш детальні моделі були запропоновані групою Даніеля Ротмана з Массачусетського технологічного інституту (Refs.~\cite{petroff2012four, devauchelle2012ramification}). Автори пов’язали висоту рівня ґрунтових вод із напрямком і швидкістю зростання річки.
    Pierwszy ilościowy model opisujący ewolucję takich rzek przedstawił w 1980 roku Dunne \cite{dunne1980formation}. Bardziej szczegółowe modele zostały zaproponowane przez grupę Daniela Rothmana z Massachusetts Institute of Technology (Refs.~\cite{petroff2012four, devauchelle2012ramification}). Autorzy powiązali wysokość poziomu wód gruntowych z kierunkiem i szybkością wzrostu rzeki.

    %Остання модель передбачає однорідність проникної здатності і сталу висоту ґрунту, ширина річки вважається достатньо малою, а тому апроксимується лінією, а процес ерозії розглядають лише в околиці джерела.
    Ten drugi model zakłada jednorodność przepuszczalności i stałą wysokość gruntu, szerokość rzeki uważa się za wystarczająco małą i dlatego jest przybliżona linią \cite{peterson1998singular,carleson2002laplacian,gubiec2008fingered}, a proces erozji uwzględnia się tylko w pobliżu źródła.

    \section{Wody podziemne}

      Wodę zgromadzoną w zbiorniku wód podziemnych opisuje prawo Darcy'ego \cite{darcy1856fontaines}:
      
      \begin{equation}
        \vec{u}=-\frac{\kappa}{\mu} \nabla p
      \end{equation}	
      
      Równanie to opisuje prędkość filtracji ($\vec{u}$) płynu o lepkości dynamicznej $\mu$ przez ośrodek porowaty (np. piasek lub skały) o przepuszczalności $\kappa$ pod ciśnieniem $p$. 
    
      Aby obliczyć, ile wody przepływa przez określony punkt na płaszczyźnie $xy$, gdzie sieć się rozrasta, po prostu całkujemy prędkość Darcy'ego w danych współrzędnych $xy$ wzdłuż osi poziomej $z$ (wysokość zbiornika):
      
      \begin{equation}
        \vec{q}(x,y)=\int \vec{u}(x,y,z)\textrm{d}z
      \end{equation}
    
      Teraz korzystamy z założenia Dupuit \cite{dupuit1863etudes}, które mówi, że wody gruntowe płyną poziomo. Ponadto zakładamy, że ciśnienie powodujące przepływ jest po prostu ciśnieniem hydrostatycznym $p = \rho g h $ ($\rho$ -- gęstość wody, $g$ -- przyspieszenie grawitacyjne, $h$ -- wysokość Tabela wód podziemnych). Dla takiego ciśnienia $\nabla p$ jest niezależne od współrzędnej $z$, a powyższa całka upraszcza się do iloczynu prędkości filtracji $\vec{u}$ i wysokości słupa wody $h(x, y)$ w danym miejscu:
      
      \begin{equation}
        \label{qq}
        \vec{q}(x,y)=h\vec{u}=-h \frac{\kappa}{\mu} \nabla(\rho g h)=-\nabla \left(\frac{\kappa \rho g}{2\mu}h^2(x,y)\right) = - \nabla \phi(x,y) \,,
      \end{equation}
      
      gdzie wprowadziliśmy potencjał $\phi(x,y)$:
      
      \begin{equation}
        \phi(x,y) = \frac{\kappa \rho g}{2\mu}h^2(x,y) \,.
      \end{equation}
    
      Na koniec wyprowadzamy równania opisujące pole $\phi$ z równania ciągłości, uwzględniając opady (opisane przez średnią objętość opadów na jednostkę czasu i powierzchnię — $P$). Zmianę masy kolumny płynu ($M$) zamkniętej w obszarze $S$ można opisać następująco:

      \begin{gather*}
        \frac{\partial M}{\partial t}=- \int\limits_{\partial S} \vec{q}\cdot \hat{n} \ \textrm{d}l + \int\limits_S P \ \textrm{d}S
        \\
        \frac{\partial}{\partial t} \int\limits_S \rho h \ \textrm{d}S=\int\limits_S \left(-\nabla \cdot \vec{q} + P\right)\textrm{d}S
        \\
        \rho \frac{\partial h}{\partial t}=-\nabla \cdot \vec{q} + P
      \end{gather*}	

      W tym miejscu należy skomentować skale czasowe w rzeczywistych systemach. Średni czas między opadami to 10 dni, a średni czas przepływu wody przez system to $10^4$ dni. Oznacza to, że wahania wysokości zwierciadła wód gruntowych $h$ są bardzo małe i jako $P$ możemy przyjąć średnią roczną wielkość opadów. Ponadto szybkość wzrostu sieci rzecznej szacuje się na około 1~mm/rok, a charakterystyczny czas zmian geometrii to $10^4$ lat. To z kolei oznacza, że w skalach czasowych odpowiadających wzrostowi sieci rzecznej możemy pominąć $ \frac{\partial h} {\partial t} $ w równaniu ciągłości, otrzymując:
      
      \begin{equation}
    		\nabla \cdot \vec{q} = P \,.
    	\end{equation}
      
      Używając wcześniej zdefiniowanego potencjału $\phi$ otrzymujemy równanie Poissona:
      
      \begin{equation}
        \label{poisson}
    		\Delta \phi = -P/\kappa
    	\end{equation}
      
      lub równanie Laplace'a, gdzie nie ma opadów ($P=0$):
      
      \begin{equation}
        \label{laplace}
    		\Delta \phi = 0 \,.
    	\end{equation}	

      Równania te muszą być uzupełnione odpowiednimi warunkami brzegowymi. W naszym przypadku zakładamy, że rzeka płynie bezpośrednio po warstwie nieprzepuszczalnej (przy $h = 0$), czyli $\phi = 0$ na całej jej długości. Dodatkowo granice domeny są często nieprzepuszczalne, co można zapisać jako odblaskowy warunek brzegowy ($\frac{\partial \phi}{\partial \vec{n}} = 0$). Wreszcie, gdy nie ma opadów, zakładamy, że woda wchodzi do układu przez jedną z granic (na przykład z odległych lodowców) -- można to opisać jako stały przepływ pola $\phi$ wzdłuż rozważanej ściany ($\frac{\partial \phi}{\partial \vec{n}} = const.$).
      
      W ten sposób udało nam się zredukować trójwymiarowy problem przepływu płynów do obliczenia dwuwymiarowego potencjału, który niesie pełną informację o dynamice wód gruntowych.

  \section{Rozwiązywanie równania Laplace'a}\label{chapter:solving}
    
    We współrzędnych biegunowych (gdzie kierunek stycznej do palca na wierzchołku ustawia $\theta = 0$) pole w pobliżu wierzchołka można rozszerzyć \cite{derrida1992needle , petroff2013bifurcation}:
    
    \begin{equation}\label{phi_polar}
      \phi(r,\theta)=a_1r^{1/2}\cos\frac{\theta}{2}+a_2r \sin \theta+a_3 r^{3/2} \cos\frac{3\theta}{2}+\mathcal{O}\left(r^2\right) \,,
    \end{equation}

    Równ. \eqref{phi_polar} obowiązuje również w przypadku pól Poissona, ponieważ w sąsiedztwie wierzchołka wkład strumienia z członu źródłowego jest pomijalny w porównaniu do strumienia z obszarów oddalonych od wierzchołka. Dla każdego z wiodących współczynników $a_i$ w równaniu \eqref{phi_polar} możemy znaleźć interpretację fizyczną.

    Po pierwsze, współczynnik $a_1$ jest powiązany z całkowitym strumieniem na małym okręgu o promieniu $r_0$ wokół końcówki:
    
    \begin{equation}\label{circle}
      J|_{r_0} = \oint_{r_0} (-\kappa \nabla \phi) \cdot \hat{n} \ \textrm{d}l = 2 \kappa a_1 r_0^{1/2} + \mathcal{O}\left(r_0^{3/2}\right) \,.
    \end{equation}

    Współczynnik $a_2$ jest powiązany z asymetrią pola wokół wierzchołka. Przy dodatnim $a_2$ strumień pola jest większy po prawej stronie wierzchołka, a przy ujemnym $a_2$ — po lewej stronie. Palec rośnie jednak w kierunku największego strumienia i w efekcie rośnie w taki sposób, że $a_2$ zawsze znika (zasada lokalnej symetrii \cite{cohen2015path}).
    
    Wreszcie $a_3$ jest połączona z drugą pochodną pola. Jeśli ponownie skupimy się na małym okręgu o promieniu $r_0$ wokół końcówki i zbadamy pole jako funkcję kąta $\theta$, zauważymy, że przy ustalonych $a_1>0$ i $a_2=a_3=0$ pole ma pojedyncze maksimum przy $\theta = 0$. Im mniejszy współczynnik $a_3$, tym bardziej płaskie maksimum pola wokół końcówki. W końcu, gdy druga pochodna $\phi$ znika, co odpowiada ujemnej wartości $a_3/a_1$:
    
    \begin{equation}\label{a3a1}
      \frac{\partial^2 \phi}{\partial \theta^2}\big|_{\theta=0, r=r_0} = 0 \implies a_3/a_1 = -\frac{1}{9 r_0} \,, 
    \end{equation}
    
    to pojedyncze maksimum przekształca się w dwa maksima w $\pm \theta_0$. Zauważ, że wartość progowa $a_3/a_1$ zależy od odległości $r_0$ od końcówki, przy której analizowane jest pole. Dla nieskończenie małych $r_0$ profil pola jest zawsze symetryczny z jednym maksimum przy $\theta=0$.

    Aby otrzymać współczynniki $a_i$, możemy po prostu rozwiązać odpowiednie równanie dla pola (Laplace'a lub Poissona) metodą elementów skończonych, a następnie korzystając z postaci całkowej współczynników:
    
    \begin{equation}
      \label{a1}
      a_1 = \frac{1}{\pi r_0^{1/2}}\int^{\pi}_{-\pi} \phi(r_0,\theta)\cos\frac{\theta}{2}\textrm{d}\theta \,,
    \end{equation} 
    
    \begin{equation}
      \label{a2}
      a_2 = \frac{1}{\pi r_0}\int^{\pi}_{-\pi} \phi(r_0,\theta)\sin\theta \textrm{d}\theta \,,
    \end{equation}
    
    \begin{equation}
      \label{a3}
      a_3 = \frac{1}{\pi r_0^{3/2}}\int^{\pi}_{-\pi} \phi(r_0,\theta)\cos\frac{3\theta}{2}\textrm{d}\theta
    \end{equation}	
    
    %obliczyć je. Przeprowadzamy ją w programie RiverSim który był inspirowany rozwiązaniem w FreeFEM++\cite{hecht2012new} początkowo stworzonych przez grupę Daniela Rothmana w MIT \cite{petroff2011geometry, petroff2013bifurcation, cohen2015path} i dalej rozwijanych w grupie Piotra Szymczaka \cite{morawiecki2016problem, zukowski2019zwiazek}.



  \section{Ewolucja sieci rzecznej}
    
    %\subsection{Reguły wzrostu}

    W najogólniejszym przypadku prędkość wzrostu może być dowolną funkcją pola ($v = f(\phi)$), ale w klasycznym wzroście Laplace'a jest proporcjonalna do gradientu pola -- $f(\phi) = \alpha |\nabla \phi|$, gdzie $\alpha$ jest stałą proporcjonalności. Jednak, prawo potęgowe zostały odnotowane w wielu różnych systemach fizycznych, np. przebicie dielektryczne \cite{niemeyer1984fractal} i -- po tych pracach -- założymy tutaj, że prędkość końcówki jest proporcjonalna do strumienia wchodzącego w nią pola ($J$) do potęgi $\eta$. Przypominając równanie \eqref{circle} mamy \cite{carleson2002laplacian, selander1999two}:
       
    \begin{equation}\label{velocity}
      v = \alpha a_1^\eta \,.
    \end{equation}
      
    W literaturze dotyczącej modelu cienkiego palca stosuje się dwa różne deterministyczne kryteria podziału -- kryterium prędkości i kryterium kształtu pola. Pierwsze kryterium może być wprost zaimplementowane w modelu cienkiego palca jako próg $a_1$: $a_1 > a_1^c$.

    Drugie kryterium jest związane z ekstremami strumienia (w funkcji kąta biegunowego) \cite{petroff2013bifurcation, kaandorp2001algorithmic_Chapter4.4}, a więc ze współczynnikiem $a_3$. Gdy dla danego promienia $r_0$ strumień pola ma wysokie pojedyncze maksimum, palec rośnie w kierunku tego maksimum. Jeśli jednak strumień pola z boków wierzchołka staje się porównywalny do tego z przodu, a nawet w końcu staje się większy (co odpowiada pojawieniu się dwóch maksimów przy $\pm \theta_0$), palec próbuje rosnąć w dwóch kierunkach jednocześnie, co skutkuje bifurkacją. Mówiąc dokładniej, mówimy, że palec dzieli się, gdy $a_3/a_1$ jest mniejsze niż jakaś wartość krytyczna.

  \chapter{Rozwiązanie numeryczne i struktura oprogramowania}

    \hspace{1em} \= 
    Pole wód podziemnych kształtuję erozje w oklicy żródła i jak skutek dynamikę i rozwój sięci. Z matematycznego modelu dla opisu sieci rzecznych otrzymujemy równania dla opisu wód podziemnych w postaci równania Laplacea \ref{laplace}(lub Poissona \ref{poisson}). Pole w okolicy źródła jest aproxymowane współcznynnikami $a_i$ (\ref{a1} \ref{a2} \ref{a3}). Całkowanie współcznynników jak i rozwiązywanie też w swoją kolej wymaga metod numerycznych. W ogólnym przypadku równanie Laplace można rozwiązać metodami numerycznymi, a w szczegolności w tej pracy skorzystano z metody skończonych elementów. \\ \indent
    %В попередніх проектах вже було представлені рішення для задачі еволюції мережі річки. Один з розв'язків був написаний з використанням Фреефем++ і Матлаб. Інший, з допомогою конформних перетворень. Однак для отримання і ще більших мереж річок потрібен був оптимальніший розв'язок. Другою вимогою було використання тільки технологій із відкритим вихідним кодом, адже не кожен має можливість придбати Матлаб. Вибір припав на C++\cite{Stroustrup1997} та Python. Адже ці мови програмування є одними з найбілш росповсюдженних, а також містять в собі багато бібліотек із відкритим кодом, що полегшує написання програм. C++ -- з одного боку, він дуже швидкий, але вимогливий до написання. С++ містить реалізацію частини програми, яка займає є складною в обчисленнях, такі як алгоритми для роботи із геометрією, генерацією сітки, розязок диференціальних рівняннь. Python\cite{python3} -- має меншу обчислювальну ефективність, але набагато швидший у розробці програмного забезпечення і надає інтерактивний інструмент для написання скрипту -- Jupyter.  
    W poprzednich projektach prezentowano już rozwiązania problemu ewolucji sieci rzecznej. Jedno z rozwiązań zostało napisane przy użyciu Freefem++ i Matlaba. Inny, za pomocą przekształceń konforemnych. Jednak aby uzyskać jeszcze większe sieci rzeczne, potrzebne było bardziej optymalne rozwiązanie. Drugim wymogiem było korzystanie wyłącznie z technologii z otwartym kodem źródłowym, ponieważ nie każdy ma możliwość zakupu Matlaba. Wybór padł na C++\cite{Stroustrup1997} i Python\cite{python3}. W końcu te języki programowania należą do najbardziej rozpowszechnionych, a także zawierają wiele bibliotek z otwartym źródłołem kodem, co ułatwia pisanie programów. C++ -- z jednej strony jest bardzo szybki, ale wymagający w pisaniu. C++ zawiera implementację części programu, która jest złożona w obliczeniach, takich jak algorytmy pracy z geometrią, generowanie siatki i rozwiązywanie równań różniczkowych. Python — ma mniejszą wydajność obliczeniową, ale jest znacznie szybszy w tworzeniu oprogramowania i zapewnia interaktywne narzędzie do tworzenia skryptów — Jupyter.

    \begin{figure}[H]
      \centering
      \includegraphics[width=1\textwidth]{figs/ProgramWorkflowMainIllustration.png}
      %(1) Початкова геометрія, задавання місць на границі звідки буде рости річка, граничні умови. (2) Початкова мережа річки(можна не задавати). (3) Спрощення геометрії річки. (4) Генерація дрібнозернистого мешу. (5) Розв'язок диференційних рівнянь. (6) Визначення параметрів ряду довкола джерел. (2) Ріст мережі річки.
      %Метод конечних елементів вимагає визначення геометрії області, потім її дискретизація, створення лінійних рівнянь, розв’язування рівнянь, інтегрування коефіцієнти $a_i$ розкладу в ряд. Наведені вище кроки формують структуру програмного забезпечення \ref{program_workflow}.
      \caption {Metoda elementów skończonych wymaga wyznaczenia geometrii obszaru, następnie jej dyskretyzacji, utworzenia równań liniowych, rozwiązania równań, zintegrowania współczynników rozszerzenia $a_i$ w szereg. Powyższe kroki tworzą strukturę oprogramowania. (1) Geometria początkowa, ustalenie miejsc na granicy, z których rzeka będzie wypływać i warunki brzegowe. (2) Początkowa sieć rzeki (opcjonalnie). (3) Uproszczenie geometrii rzeki. (4) Generowanie drobnoziarnistej siatki. (5) Rozwiązywanie równań różniczkowych. (6) Wyznaczanie parametrów szeregu wokół źródeł. (2) Wzrost sieci rzecznej.}
      \label{program_workflow}
    \end{figure}
      
    W trakcie tworzenia oprogramowania było stworzono dwa rzowiązania: RiverSim\cite{riversim} - program który zawiera wszystkie algorytmy dla generacji sieci rzecznych, riversimpy\cite{riversimpy} - biblioteka w Pythonie które zawiera algorytmy ułatwiające tworzenie skryptów dla symulacji wzrostu sieci w polu Laplasowskim. 
    RiverSim zawiera niektórę dodatkowe algorytmy dla odwracalnej ewolucji wsztecznej i do przodu, a poza tym RiverSim i riversimpy zawierają tę same algorytmy, w podalszym opisie głównie skupimysię na riversimpy. 

    \section{Geometria}
      
      % В реальних середовищах еволюції русла річок даного типу, ми можемо зустріти цілий ряд чинників, котрі мають вплив на поле підземних вод. Наприклад, це можуть бути гори звідки регулярно надходить потік води, озеро котре може слугувати кінцевою точкою або початком річки. Мережа річки теж має вплив на поле підземних вод і багато інших чинників. Ця довільність геометрії продемонстрована на малюнку \ref{geometry_examples}.
      W rzeczywistych środowiskach ewolucji koryt rzecznych możemy napotkać szereg czynników, które mają wpływ na pole wód gruntowych. Na przykład mogą to być góry, z których regularnie wypływa strumień wody, jezioro, które może służyć jako punkt końcowy lub początek rzeki. Sieć rzeczna ma również wpływ na pole wód gruntowych i wiele innych czynników. Ta arbitralność geometrii jest pokazana na rysunku \ref{geometry_examples}.
      
      \begin{figure}[H]
        \centering
        \includegraphics[width=1\textwidth]{figs/geometry_examples.png}
        \caption {Szereg przykładów granicy:  brzeg z dwoma zaznaczonymi źródłami (1), granica zawierająca granicę(na przykład jezioro) (2), basen rzeki aproksymowany łamą linią i częściowo odzwierciedloną rżeką (4), dwa prostokąty z różną szerokością nie powiązane topologicznie(5).}
        \label{geometry_examples}
      \end{figure}
      
      %І що б охопити всю цю довільність геометрії, було створено цілий ряд класів і функцій. Деякі найголовніші класи і функції: Point, Polar, Line, Boundary, BoundaryConditions, Sources, Branch, Rivers, Region і функція BoundaryGenerator. Приклади використання даних функцій розглянемо далі.
      Aby pokryć całą tę arbitralność geometrii, stworzono szereg klas i funkcji\ref{GeometryClasses}. Niektóre z najważniejszych klas i funkcji to Point, Polar, Line, Boundary, BoundaryConditions, Sources, Branch, Rivers, Region i funkcja BoundaryGenerator. Poniżej rozważymy przykłady użycia tych funkcji.
      
      \begin{figure}[H]
        \centering
        \includegraphics[width=0.7\textwidth]{figs/GeometryClasses.png}
        \caption {Ilustracja objektów zdefiniowanych w bibliotece riversim i ich relacje pomiędzy sobą przy konfigurowaniu geometrii.}
        \label{GeometryClasses}
      \end{figure}

      \begin{figure}[H]
        \centering
        \includegraphics[width=0.9\textwidth]{figs/region_workflow.png}
        \caption{Ilustracja kolejności kroków przy definicji regionu. Definicja wszystkich punktów i zapisanie ich do obrednych list t\_PointList jeżęli należą do różnych brzegów (1). Definicja linij i indeksów i też przepisanie ich do obrędnych list t\_LineList (2). Definicja punktów źródłołych na granicy w klasie Source (3). Denicja warunków brzegowych (4).}
        \label{region_workflow}
      \end{figure}

      %Спочатку задаємо впорядковану множину координат з допомогою класу Point і ліній з допомогою класу Line для визначення границі. В програмі границя репрезентується класом Boundary. Таких границь може бути декілька. Група границь котрим присвоєний унікальний індекс утворює регіон який репрезентується класом Region. Границя - це замкнута лінія, іншими словами полігон. В регіоні немає обмежень на кількість границь. Границя також може містити цілковито іншу границю, проте перетин ліній не допускається. Щоб утворити дірку в границі потрібно визначити координату в межах цієї границі і присвоїти до списку дір який зберігається в класі Region. Наступним кроком є визначення місць звідки буде відбуватися ріст мережі річки. Такими місцями може бути кожна  точка границі і джерел може бути необмежена кількість(практично обмежена сумарної кількістю координат границь). Для зберігання інформації про початкові координати джерел створено клас Source. Цей клас зберігає унікальний номер кожного джерела, номер границі на котрій розташовується і номер координати на даній границі.
      Najpierw określamy uporządkowany zestaw współrzędnych za pomocą klasy Point i linii za pomocą klasy Line, aby określić granicę. W programie granica jest reprezentowana przez klasę Boundary. Takich granic może być kilka. Grupa granic, którym przypisano unikalny indeks, tworzy region reprezentowany przez klasę Region. Granica jest zamkniętą linią, innymi słowy wielokątem. W regionie nie ma ograniczeń co do liczby granic. Jedna granica może również zawierać inną granicę, ale przecięcie linii jest niedozwolone. Aby utworzyć otwór w granicy, należy zdefiniować współrzędną w obrębie tej granicy i przypisać ją do listy otworów przechowywanej w klasie Region. Kolejnym krokiem jest określenie miejsc, z których nastąpi rozwój sieci rzecznej. Takimi miejscami może być każdy punkt granicy, a źródeł może być nieograniczona (praktycznie ograniczona całkowitą liczbą współrzędnych granic). Klasa Source została stworzona do przechowywania informacji o początkowych współrzędnych źródeł. Ta klasa przechowuje unikalny numer każdego źródła, numer granicy, na której się znajduje, oraz numer współrzędnej na tej granicy.

      \begin{mintedbox}{python}
        from riversim import *

        outer_boundary = Boundary()
        outer_boundary.vertices.extend([Point(0.13, 0.011), Point(0.31, 0), Point(0.74, 0.15), Point(0.95, 0.35), Point(0.8, 0.75), Point(0.47, 0.85), Point(0.152, 0.76), Point(0, 0.5), Point(0.025, 0.3)])
        outer_boundary.lines.extend([Line(0, 1, 1), Line(1, 2, 1), Line(2, 3, 1), Line(3, 4, 1), Line(4, 5, 2), Line(5, 6, 2), Line(6, 7, 1), Line(7, 8, 1), Line(8, 0, 1)])

        inner_boundary = Boundary()
        inner_boundary.vertices.extend([Point(0.3, 0.7), Point(0.5, 0.76), Point(0.65, 0.7), Point(0.66, 0.59)])
        inner_boundary.lines.extend([Line(0, 1, 1), Line(1, 2, 3), Line(2, 3, 3), Line(3, 0, 1)])

        region = Region()
        region[1] = outer_boundary; region[2] = inner_boundary
        region.holes.append(Point(0.4, 0.7))

        sources = Sources()
        sources[1] = t_source_coord(1, 1) 
        sources[2] = t_source_coord(1, 8) 
        sources[3] = t_source_coord(2, 3)\end{mintedbox}

      %Після визначення регіону і розташування джерел, тепер можемо перейти до побудови геометрії річки. Всі дані про геометрію річок і алгоритми містяться в класі Rivers. Rivers містить унікальний номер для кожної річки, котрий має теж саме значення,  що й номер джерела в Sources. Для ініціалізації класу Rivers, потрібно конвертувати дані з класу Sources в координати і напрямок. Для цього служить функція GetSourcesIdsPointsAndAngles класу Region аргументом котрої є Sources. В результаті ми отримаємо набір індексів річок і відповідні їм координати і напрямок перпендикулярний до границі. Для визначення точного напрямку перпендикуляру, має значення напрямок координати при задаванні границі. Прийнято, що перпендикуляр буде з лівої сторони від напрямку координат. Тому якщо звернути увагу на регіон де є дірка по центрі, то зовнішня границя має протилежний напрямок нумерації координат відносно внутрішньої.
      Po określeniu regionu i lokalizacji źródeł możemy przystąpić do konstruowania geometrii rzeki. Wszystkie dane geometrii rzeki i algorytmy są zawarte w klasie Rivers. Rzeki zawierają unikalny numer dla każdej rzeki, który ma takie samo znaczenie jak numer źródła w Źródłach. Aby zainicjować klasę Rivers, należy przekonwertować dane z klasy Sources na współrzędne i kierunek. W tym celu jako argument służy funkcja GetSourcesIdsPointsAndAngles klasy Region, której argumentem jest Sources. W rezultacie otrzymamy zestaw indeksów rzecznych i odpowiadających im współrzędnych oraz kierunek prostopadły do granicy. Aby określić dokładny kierunek prostopadłej, podczas wyznaczania granicy ważny jest kierunek współrzędnych. Zakłada się, że prostopadła będzie po lewej stronie kierunku współrzędnych. Dlatego jeśli zwrócisz uwagę na obszar, w którym znajduje się dziura w środku, wówczas zewnętrzna granica ma przeciwny kierunek numeracji współrzędnych w stosunku do wewnętrznej.
      
      \begin{figure}[H]
        \centering
        \includegraphics[width=0.6\textwidth]{figs/rivers_initialization.png}        
        \caption {Indeksy brzegów i odpowiednich współrzędnych, którę są przechowywane w klasie Source, są konwertowanę w wspówrzędne i kąt nornalnej linii w danym punkcie granicy. Te dane są wykorzystywane dla inicializacji struktury Rivers która przechowywuję dane o sieci rzecznej.}
        \label{rivers_initialization}
      \end{figure}

      \begin{mintedbox}{python}
        rivers = Rivers()
        rivers.initialize(region.getSourcesIdsPointsAndAngles(sources))\end{mintedbox}
      
        %Вище вказувалося, що в більшості випадків біфуркація річки відбувається на дві частини. А якщо поділів відбувається більше, ми можемо вважати це двома послідовними достатньо близько розташованими між собою біфуркаціями. Поміж біфуркаціями річка апроксимується ламаною лінією. Інформація  про цю лінію криється в класі Branch. А інформація про те котрі частини річки з'єднуються з іншими частинами річки в пунктах біфуркації міститься в графі котрий в свою чергу міститься в класі Rivers. Класс Rivers надає можливості для легкого способу працювати із геометрією річки, а саме: отримання інформації про поточний стан річок(довжини, відношення між частинами річками, визначення кривизни, координати джерел і тд), розвиток мережі річки(додавання нових координат до річки при рості, згладжування кривизни, створення нових річок, додавання нових пунктів біфуркації), зменшення довжини річки і  видалення пунктів біфуркації для полегшення обрахунків при оберненій еволюції. 
      Powyżej zaznaczono, że w większości przypadków rzeka rozdziela się na dwie części. A jeśli podziałów jest więcej, możemy to uznać za dwa kolejne bifurkacje dostatecznie blisko siebie. Pomiędzy punktami bifurkacji rzeka jest aproksymowana linią przerywaną. Informacje o tej linii znajdują się w klasie Branch. A informacja o tym, które odcinki rzeki łączą się z innymi odcinkami rzeki w punktach rozwidlenia, zawarta jest w grafie, który z kolei jest zawarty w klasie Rivers. Klasa Rivers daje możliwość łatwej pracy z geometrią rzek, a mianowicie: uzyskiwania informacji o aktualnym stanie rzek (długości, relacje między odcinkami rzek, określanie krzywizny, współrzędne źródeł itp.), opracowywania sieci rzecznej ( dodawanie nowych współrzędnych do rzeki podczas wzrostu, wygładzanie krzywizny, tworzenie nowych rzek, dodawanie nowych punktów bifurkacji), zmniejszanie długości rzeki i usuwanie punktów bifurkacji w celu ułatwienia obliczeń podczas ewolucji odwrotnej.
      
      \begin{mintedbox}{python}
        rivers_ids = t_sources_ids(); rivers_ids.extend([1, 2, 3])
        ds = 0.01
        tip_points = t_PolarList(); tip_points.extend([Polar(ds, 0), Polar(ds, 0), Polar(ds, 0)])
        boundaries_ids = t_boundaries_ids(); boundaries_ids.extend([1, 2, 1])
        rivers.addPolars(rivers_ids, tip_points, boundaries_ids)
      
        sub_branch_ids = rivers.createSubBranches(1, -3.1415/5, 3.1415/5)\end{mintedbox}

      %Оскільки мережа річки котра міститься в класі Rivers опирається в своїй реалізації на клас Boundary, то для кожного сегменту річки ми можемо задати унікальні граничні умови. Наприклад, можна врахувати "опір" русла ріки і збільшення висоти підземних вод вздовж.
      Ponieważ sieć rzeczna zawarta w klasie Rivers opiera się w swojej implementacji na klasie Boundary, możemy ustawić unikalne warunki brzegowe dla każdego odcinka rzeki. Naprzykład, możemy uwzględnić „opór” koryta rzeki i wzrost wysokości wód gruntowych wzdłuż niego.

      \begin{figure}[H]
        \centering
        \includegraphics[width=0.9\textwidth]{figs/tree_coarsening.png}        
        \caption {Ilustracja zmijszenia gęstości współrzędnych na granicy przy zachowaniu wystarczającej dokładności.}
        \label{tree_coarsening}
      \end{figure}

      \begin{wrapfigure}{r}{0.5\textwidth}
        \begin{center}
          \vspace{-20pt}
          \includegraphics[width=0.45\textwidth]{figs/descritization_reducing.jpg}
        \end{center}
        \caption {Ilustracja algorytmu wygładzenie brzegu.}
        \label{descritization_reducing}
      \end{wrapfigure}

      %Кількість елементів сітки на котру ми розділюємо регіон має прямий вплив на розмір матриці лінійних рівняння, а тому на час знаходження розв'язку диференційного рівняння. Щоб зменшити час обчистленнь, ми можемо зменшити густини координат границі річки, при цьому не втрачаючи на точності. Для цього ми робимо процедуру огрублення границь частин річки. Тепер нам потрібно класи  Sources, Region та Rivers вкласти в границю Boundary, оскільки генератор сітки вимагає тільки  границю як аргумент. Другою проблемою, котра згадувалася вище є те, що немає можливості задати граничні умови в середині регіону, а тільки на границі. Для цього лінії з котрих складається мережа річки розділяються на дві лінії котрі знаходяться дуже близько одна до одної.
      Liczba elementów siatki, na jakie dzielimy obszar, ma bezpośredni wpływ na wielkość macierzy równań liniowych, a więc na czas znalezienia rozwiązania równania różniczkowego. Aby skrócić czas obliczeń, możemy zmniejszyć gęstość współrzędnych granicy rzeki bez utraty dokładności. Zmniejszenie zagęszczenia współrzędnych na granicy opiera się na następującej idei: każda kolejna współrzędna zmienia kierunek linii o pewien kąt. Jeśli kąt jest bardzo mały, możemy założyć, że współrzędne leżą praktycznie na tej samej linii. Dlatego możemy usunąć wszystkie współrzędne pośrednie i pozostawić tylko te skrajne. Aby znaleźć „skrajne” współrzędne linii, iterujemy po wszystkich współrzędnych i obliczamy całkowity kąt odchylenia, gdy tylko ten kąt stanie się większy niż wartość krytyczna, traktujemy tę współrzędną jako skrajną.

    \section{Generacja siatki}

      \begin{figure}[H]
        \centering
        \includegraphics[width=0.9\textwidth]{figs/mesh_generation.png}        
        \caption {Wszystkie brzegi które są zawierane w klasie Region, a także brzegi rzek w klasie Rivers łączą się w jeden zamnknięty brzeg (1). Z pomocą Triangle na bazie jednej zamnkiętej granicy jest generowana siatką trójkątowa (2). Siatka trójkątowa z pomoca biblioteki Tethex jest kowertowana w siatke prostokątów (3).}
        \label{mesh_generation}
      \end{figure}

      %Для генерації сітки нам потрібна замкнута границя Boundary. Для цього існує функція BoundaryGenerator, котра об'єднує класи  Sources, Region та Rivers в одну границю Boundary. Другою проблемою, котра згадувалася вище є те, що немає можливості задати граничні умови в середині регіону, а тільки на границі. Для цього лінії з котрих складається мережа річки розділяються на дві лінії котрі знаходяться достатньо близько одна до одної.
      Aby wygenerować siatkę, potrzebujemy zamkniętej granicy Boundary. W tym celu dostępna jest funkcja BoundaryGenerator, która łączy klasy Sources, Region i Rivers w jedną granicę Boundary. Drugi problem, o którym była mowa powyżej, polega na tym, że nie ma możliwości ustalenia warunków brzegowych w środku regionu, a jedynie na granicy. W tym celu linie tworzące sieć rzeczną są podzielone na dwie linie, które są wystarczająco blisko siebie.

      \begin{mintedbox}{python}
        region_params = RegionParams()
        region_params.smoothness_degree = 0.2
        region_params.river_width = 1e-8
        boundary = BoundaryGenerator(sources, region, rivers, region_params)\end{mintedbox}

      %Коли є замкнута границя можна згенерувати сітку. Для цього була використана C++ бібліотека \cite{szewczuk1996triangle}. Методи і алгоритми бібліотеки Traingle містяться в однойменному класі. Triangle генерує Деланау сітку. Triangle дає можливість задати значення мінімального кута трикутника, мінімальної і максимальної довжини сторони трикутника, мінімальної і максимальної площі трикутника, співвідношення сторін трикутника та інше. Другим важливим аспектом є генерація достатньо малої сітки в місцях, де поле підземних вод змінюється найшвидше -- довкола джерел. Для цього можна задати множину координат(а саме координат джерел), де буде обмежена радіально площа трикутника відносно даних точок. Функція котра обмежує площу трикутника виглядає наступним чином:
      Gdy istnieje zamknięta granica, można wygenerować siatkę. W tym celu wykorzystano bibliotekę C++ Triangle\cite{szewczuk1996triangle}. Metody i algorytmy biblioteki Traingle są zawarte w klasie o tej samej nazwie. Trójkąt generuje siatkę Delaunaya. Trójkąt pozwala ustawić wartość minimalnego kąta trójkąta, minimalną i maksymalną długość boku trójkąta, minimalną i maksymalną powierzchnię trójkąta, stosunek boków trójkąta itp. Drugim ważnym aspektem jest generowanie odpowiednio małej siatki w miejscach, w których pole wód podziemnych zmienia się najszybciej - w okolicach źródeł. Aby to zrobić, możesz określić zestaw współrzędnych (czyli współrzędne źródeł), w których obszar trójkąta względem danych punktów będzie ograniczony promieniowo. Funkcja ograniczająca pole trójkąta wygląda następująco:
      \begin{equation}
        A(r) = A_{min} + (A_{max} - A_{min}) \frac{1 - \exp{(\frac{-(\frac{r}{r_{ref}})^{exponant}}{2 \sigma^2})}}{1 + \exp{(\frac{-(\frac{r}{r_{ref}})^{exponant}}{2 \sigma^2})}} 
      \end{equation}

      %Розв'язувач Deal.II\cite{dealII94} вимагає сітки із квадратними елементами. Для цього ми використовуємо бібліотеку C++  Tethex \cite{tethex}  котра конвертує трикутні елементи сітки у чотирикутники, розбиваючи один трикутний елемент на три квадратних, чим збільшуючи кількість елементів сітки у три рази.
      Solver Deal.II\cite{dealII94} wymaga siatki z elementami kwadratowymi. W tym celu używamy biblioteki Tethex \cite{tethex} C++, która konwertuje trójkątne elementy siatki na czworoboki, dzieląc jeden trójkątny element na trzy kwadratowe, zwiększając w ten sposób liczbę elementów siatki trzykrotnie.

      \begin{mintedbox}{python}
        mesh_params = MeshParams()
        mesh_params.max_area = 1e6
        mesh_params.min_area = 6e-7
        mesh_params.max_edge = 1
        mesh_params.min_edge = 8e-12
        mesh_params.ratio = 2.3
        mesh_params.refinment_radius = 5e-3
        mesh_params.exponant = 1
        mesh_params.sigma = 1.9
      
        triangle = Triangle(mesh_params)
        triangle.mesh_params.tip_points = rivers.TipPoints()
        mesh = triangle.generate(boundary, region.holes)\end{mintedbox}

    \section{Warunki brzegowe}

      %Кожна лінія містить також номер(посилання) граничної умови. Boundaries -- клас котрий містить набір пар із унікальним номером і відповідною йому граничною умовою котра може бути двох типів: Діріхлет і Ноймана. Граничну умову можна задати тільки на граничній лінії, іншими словами задати лінію посеред регіону і граничну умову на ній не можна. Проте лінію завжди можна апроксимувати дуже тонким прямокутником, тож за потреби це не є проблемою.
      Każda linia zawiera również numer (odniesienie) warunku brzegowego. Boundaries -- klasa zawierająca zbiór par o unikalnym numerze i odpowiadającym mu warunku brzegowym, który może być dwojakiego rodzaju: Dirichlet i Neumann. Warunek brzegowy można ustawić tylko na linii granicznej, innymi słowy, nie można ustawić linii pośrodku regionu i warunku brzegowego na nim. Jednak linię zawsze można przybliżyć bardzo cienkim prostokątem, więc w razie potrzeby nie stanowi to problemu.

      \begin{mintedbox}{python}
        boundary_conditions = BoundaryConditions()
        boundary_conditions[1] = BoundaryCondition(DIRICHLET, 0)
        boundary_conditions[2] = BoundaryCondition(NEUMAN, 0)
        boundary_conditions[3] = BoundaryCondition(NEUMAN, 1)\end{mintedbox}

    \section{Rozwiazanie pola wód podziemnych}

      \begin{figure}[H]
        \centering
        \includegraphics[width=0.9\textwidth]{figs/solver.png}        
        \caption {Pole wód podziemnych.}
        \label{solver}
      \end{figure}

      Deal.II\cite{dealII94} to C++ biblioteka  przeznaczona do numerycznego rozwiązywania równań różniczkowych cząstkowych przy użyciu adaptacyjnych elementów skończonych. Wykorzystuje najnowocześniejsze techniki programowania, aby zaoferować nowoczesny interfejs do złożonych struktur danych i algorytmów.

      Rozwiążemy prostą wersję równania Poissona na naszym obszarze z niezerową prawą stroną.
      
      \begin{align*}
        -\Delta \phi &= f \qquad\qquad & \text{in}\ S,
        \\
        \phi &= 0 \qquad\qquad & \text{on}\ \partial S.
      \end{align*}
      
      Rozważymy tylko szczególny przypadek $f(x)=P$.

      Od podstaw metody elementów skończonych wiemy, że potrzebne są kolejne kroki, aby przybliżyć rozwiązanie $\phi$ przybliżeniem skończonych wymiarów. Konkretnie, najpierw musimy wyprowadzić słabą postać powyższego równania, którą otrzymujemy mnożąc równanie przez funkcję testową $u$ z lewej strony i całkując po domenie $S$:
      
      \begin{align*}
        -\int_S u \Delta \phi = \int_S u f.
      \end{align*}
      
      Można to zcałkować przez części:
      
      \begin{align*}
        \int_S \nabla u \cdot \nabla \phi
        -
        \int_{\partial S} u \mathbf{n}\cdot \nabla \phi
         = \int_S u f.
      \end{align*}
      
      Funkcja testowa $u$ musi spełniać ten sam rodzaj warunków brzegowych (w sensie matematycznym: musi pochodzić z przestrzeni stycznej zbioru, w którym szukamy rozwiązania), więc na granicy $u=0$ w konsekwencji otrzymujemy następny wygląd słabej formy:
      
      \begin{align*}
        (\nabla u, \nabla \phi)
         = (u, f),
      \end{align*}

      gdzie zastosowaliśmy powszechną notację $(a,b)=\int_S a\; b$. Następnie problem pyta o funkcję $\phi$, dla której to stwierdzenie jest prawdziwe dla wszystkich funkcji testowych $u$ z odpowiedniej przestrzeni (która tutaj jest przestrzenią $H^1$).

      Oczywiście nie możemy znaleźć takiej funkcji w ogólnym przypadku i zamiast tego szukamy przybliżenia $\phi_h(\mathbf x)=\sum_j \Phi_j u_j(\mathbf x)$, gdzie $\Phi_j$ to nieznane współczynniki rozszerzalności, które musimy wyznaczyć („stopnie swobody” tego problemu), a $u_i(\mathbf x)$ to funkcje kształtu elementów skończonych, których będziemy używać. Aby zdefiniować te funkcje kształtu, potrzebujemy:
      
      \begin{itemize}
        \item Siatka, na której można zdefiniować funkcje kształtu;
        \item Element skończony opisujący funkcje kształtu, których chcemy użyć w komórce odniesienia (kwadrat jednostkowy $[0,1]^2$). Zwykłe funkcje Lagrange'a;
        \item Numeracja wszystkich stopni swobody w siatce;
        \item Odwzorowanie, które mówi, w jaki sposób funkcje kształtu w rzeczywistej komórce są uzyskiwane z funkcji kształtu zdefiniowanych przez klasę elementów skończonych w komórce odniesienia. Domyślnie Deal.II użyje biliniowego mapowania;
      \end{itemize}

      Dzięki tym krokom mamy teraz zbiór funkcji $u_i$ i możemy zdefiniować słabą postać problemu dyskretnego: Znaleźć funkcję $\phi_h$, czyli Znaleźć wspomniane wyżej współczynniki rozszerzalności $\Phi_j$, tak aby

      \begin{align*}
        (\nabla u_i, \nabla \phi_h)
         = (u_i, f),
         \qquad\qquad
         i=0\ldots N-1.
      \end{align*}

      Przestrzegamy tutaj konwencji, że wszystko jest liczone od zera, co jest powszechne w C i C++. To równanie można zapisać jako układ liniowy, jeśli wstawi się reprezentację $\phi_h(\mathbf x)=\sum_j \Phi_j u_j(\mathbf x)$, a następnie zaobserwujemy, że

      \begin{align*}
        (\nabla u_i, \nabla \phi_h)
        &= \left(\nabla u_i, \nabla \Bigl[\sum_j \Phi_j u_j\Bigr]\right)
        \\
        &= \sum_j \left(\nabla u_i, \nabla \left[\Phi_j u_j\right]\right)
        \\
        &= \sum_j \left(\nabla u_i, \nabla u_j \right) \Phi_j.
      \end{align*}

      Ostatecznie otrzymejmy równanie dla przebliżnoego rozwiązania $\Phi$, aby
      
      \begin{align*}
        A \Phi = F,
      \end{align*}
      
      gdzie macierz $A$ i prawa strona $F$ są zdefiniowani jak:

      \begin{align*}
        A_{ij} &= (\nabla u_i, \nabla u_j),
        \\
        F_i &= (u_i, f).
      \end{align*}

      \paragraph{Siatka adaptacyjna}

        \begin{figure}[H]
          \centering
          \includegraphics[width=0.9\textwidth]{figs/adaptive_refinment.png}        
          \caption {Elementy siątki są dzielone w tych miejscach gdzie błąd rozwiązania jest najwiekszy. W okolicy źródła pole zachowuje się jako $\frac{1}{\sqrt[2]{r}}$.}
          \label{adaptive_refinment}
        \end{figure}

        Istnieje wiele sposobów adaptacyjnego udoskonalania siatek. Podstawowa struktura algorytmu jest zawsze taka sama i składa się z pętli obejmującej następujące kroki:

        \begin{itemize}
          \item Rozwiąż równanie różniczkowe cząstkowe na bieżącej siatce;
          \item Oszacuj błąd w każdej komórce za pomocą pewnego kryterium wskazującego na błąd;
          \item Zaznacz te komórki, które mają duże błędy do udoskonalania, zaznacz te, które mają szczególnie małe błędy do zgrubienia, a resztę zostawiamy;
          \item Podziel lub połącz zaznaczone komórki, aby uzyskać nową siatkę;
        \end{itemize}

        Poza tą strukturą istnieje jednak wiele sposobów osiągnięcia tego celu. Zasadniczo różnią się tym, jak dokładnie generuje się jedną siatkę z poprzedniej. Dla siatki z trójkątów, trójkąt zaznaczony do udoskonalenia jest dzielony na dwie części poprzez wprowadzenie jednej nowej krawędzi od środka najdłuższej krawędzi do przeciwległego wierzchołka. Oczywiście punkt środkowy od najdłuższej krawędzi musi być w jakiś sposób zrównoważony poprzez udoskonalenie komórki po drugiej stronie tej krawędzi (jeśli taka istnieje). Ta metoda nie działa w przypadku czworokątów, a przynajmniej nie jest łatwa. Powodem jest to, że elementy przejściowe utworzone z czworobocznych sąsiadów czworobocznej komórki, która ma zostać udoskonalona, byłyby trójkątami, a tego nie chcemy. W związku z tym podejście do adaptacyjności wybrane w Deal.II polega na wykorzystaniu siatek, w których sąsiednie komórki mogą różnić się poziomem udoskonalenia o jeden. Powoduje to, że węzły na interfejsach komórek należą do jednej strony, ale są niezrównoważone po drugiej. Powszechnym terminem dla nich są „wiszące węzły”. Jeśli udoskonalimy siatkę globalnie, błąd spadnie jako

        \begin{align*}
          \|\nabla(\phi-\phi_h)\|_{S} \le C h_\text{max}^p \| \nabla^{p+1} \phi \|_{S},
        \end{align*}

        gdzie $C$ jest pewną stałą niezależną od $h$ i $\phi$, $p$ jest stopniem wielomianu używanego elementu skończonego, a $h_{max}$ jest średnicą największej komórki. Jeśli więc ważną jest największa komórka, to dlaczego mielibyśmy chcieć, aby siatka była drobna w niektórych częściach domeny, ale nie we wszystkich? Odpowiedź tkwi w spostrzeżeniu, że powyższy wzór nie jest optymalny. W rzeczywistości poniższe wzór jest lepszym oszacowaniem:

        \begin{align*}
          \|\nabla(\phi-\phi_h)\|_{S}^2 \le C \sum_K h_K^{2p} \| \nabla^{p+1} \phi \|^2_K.
        \end{align*}

        (Ponieważ $h_K\le h_\text{max}$, ta formuła natychmiast implikuje poprzednią, jeśli po prostu wyciągniesz rozmiar oczek z sumy.) Ta formuła sugeruje, że nie jest konieczne, aby największa komórka była mała, ale te komórki tak naprawdę potrzebują być małymi, gdzie $\| \nabla^{p+1} \phi \|_K$ jest duże! Innymi słowy: Siatka naprawdę musi być dokładna tylko wtedy, gdy rozwiązanie ma duże zmiany, na co wskazuje $p+1$ pochodna.
        
        Oczywiście to oszacowanie a priori nie jest zbyt przydatne w praktyce, ponieważ nie znamy dokładnego rozwiązania $\phi$, a za tym idzie, że nie możemy obliczyć $\nabla^{p+1} \phi$. Ale możemy obliczyć numeryczne przybliżenia $\nabla^{p+1} \phi$ bazując tylko na dyskretnym rozwiązaniu $\phi_h$.

      \paragraph{riversim}
        
        Powyższe rozumuwania teoretyczne są zaimplementowane w bibliotece riversim w pliku `solver.hpp`:
        
        \begin{mintedbox}{python}
          solver_params = SolverParams()
          solver_params.field_value = 1
          solver_params.quadrature_degree = 3
          solver_params.renumbering_type = 0
          solver_params.tollerance = 1e-12
          solver_params.num_of_iterrations =  6000
          solver_params.refinment_fraction = 0.1
          adaptive_refinment_steps = 1
        
          solver = Solver(solver_params)
          solver.openMesh(mesh)
          
          solver.openMesh(mesh)
          for j in range(adaptive_refinment_steps + 1):
              if j > 0:
                  solver.refineGrid()
              solver.setupSystem()
              solver.assembleSystem(boundary_conditions)
              solver.solve()\end{mintedbox}

    \section{Calkowanie parametrow szeregu}
      
      \begin{figure}[H]
        \centering
        \includegraphics[width=0.9\textwidth]{figs/series_params_integration.png}        
        \caption {Ilustracja rozkładu pola w okolicy źródła na współczynniki $a_n$.}
        \label{series_params_integration}
      \end{figure}

      Powyżej już było pokazano że erozja jest największa w miejscach gdzie gradient pola jest największy. Takim miejscem z największym gradientem są oklicy źródeł. We współrzędnych biegunowych pole w pobliżu wierzchołka można rozszerzyć z pomocą równania \ref{series_params_integration}. Gdzie kazdy parameter $a_n$, $n \epsilon [1, 3]$ ma fizyczną interpretację (\ref{circle}, \ref{a3a1}) i jest powiązany z regułami wzrostu (\ref{velocity}). Współczynniki $a_n$ są wylicznę z postaci całkowej \ref{a1}, \ref{a2} i \ref{a3}. Aby zmniejszyć szum numeryczny uśredniamy postaci całkowe wzdłuż promienia $r$:
      
      \begin{equation}
        \label{a1_num}
        a_1 = \frac{\int^{r_{max}}_{r_{min}} \int^{\pi}_{-\pi} \phi(r, \theta) \cos \frac{\theta}{2} \omega(r) \textrm{d} \theta \textrm{d} r}{\int^{r_{max}}_{r_{min}} \int^{\pi}_{-\pi} \cos^2 \frac{\theta}{2} \omega(r) \textrm{d} \theta \textrm{d} r} \,,
      \end{equation} 
      
      \begin{equation}
        \label{a2_num}
        a_2 = \frac{\int^{r_{max}}_{r_{min}} \int^{\pi}_{-\pi} \phi(r, \theta) \sin \theta \omega(r) \textrm{d} \theta \textrm{d} r}{\int^{r_{max}}_{r_{min}} \int^{\pi}_{-\pi} \sin^2 \theta \omega(r) \textrm{d} \theta \textrm{d} r} \,,
      \end{equation}
      
      \begin{equation}
        \label{a3_num}
        a_3 = \frac{\int^{r_{max}}_{r_{min}} \int^{\pi}_{-\pi} \phi(r, \theta) \cos \frac{3 \theta}{2} \omega(r) \textrm{d} \theta \textrm{d} r}{\int^{r_{max}}_{r_{min}} \int^{\pi}_{-\pi} \cos^2 \frac{3 \theta}{2} \omega(r) \textrm{d} \theta \textrm{d} r}
      \end{equation}	

      Gdzie $\omega(r)$ funkcja wagi ma postać:

      \begin{equation}
        \label{integration_weight}
        \omega(r) = \exp(-{(\frac{r}{r_{ref}})}^e)
      \end{equation}

      Całka $\int^{r_{max}}_{r_{min}} \int^{\pi}_{-\pi} f(r, \theta) \textrm{d} \theta \textrm{d} r$ jak i równanie dla pola wód podziemnych, jest wyliczana numerycznie. Chociaż mamy dyskretnę rozwiązania pola wód podziemnych, ale wciąż otzrymanie wartości pola $\phi(x, y)$ w dowolnym punkcie nadal jest numerycznie skomplikowanym, o ile wymaga iterację po całej siatce regionu, a po znaleziniu odpowiedniego elementu -- interpolacje. Przez to przy aproksymówaniu całki skończoną sumą celem jest minimizacja ilości elementów. Kwadratura Gaussa jest dobrym rozwiązaniem, ale w danej pracy korzystamy z iteracujnej metody prostokątów:

      \begin{equation}
        \label{numerical_integral}
        \int^{b}_{a} f(x) \textrm{d} x = h \sum_{i = 0}^{n - 1} f(x_i + \alpha h),    \\
        h = \frac{a - b}{n}  
      \end{equation}

      Ta całka jest rozwiązywana iteracyjnie aby osiągnąć potrzebną dokładność \cite{Press2007}:

      \begin{mintedbox}{c++}
        class Quadrature {
            public:
                size_t n = 0;
                virtual double next() = 0; };

        template<typename T> class Trapzd: virtual public Quadrature {
            public:
                T f;
                double s = 0., a, b;

                Trapzd(T func, double aa, double bb):
                    f{func}, a{aa}, b{bb} {}

                double next(){
                    ++n;
                    if (n==1) s = (b - a) / 2. * (f(a) + f(b));
                    else if (n > 1) {
                        auto tnm = pow(2., n - 2.), d = (b - a) / tnm, x = a + 0.5 * d, sum = 0.;
                        for(size_t j = 0; j < tnm; ++j) {
                            sum += f(x); x += d;
                        }
                        s = 0.5 * (s + d * sum);
                    }
                    return s;
                }
        }
        
        template<typename T> double qtrap(T func, double a, double b, double eps){
            auto s = 0., olds = 0.;
            auto t = Trapzd(func, a, b);
            for (size_t i = 0; i < (size_t)30; ++i) {
                s = t.next();
                auto cur_eps = abs(s - olds) / abs(olds);
                if (cur_eps < eps || (s < EPS && olds < EPS))
                    return s;
                olds = s;
            }
            throw Exception("qtrap: Too many steps in routine.");
        };\end{mintedbox}

        W riversimpy dla obliczenia współczynników $a_i$ służy metoda integrate (lub integrate\_new) klasy Solver:
        \begin{mintedbox}{python}
          integration_params = IntegrationParams()
          integration_params.eps = 1e-10
          integration_params.integration_radius = 3e-2
          integration_params.exponant = 2.0
          integration_params.weigth_func_radius = 1e-2        
          
          river_id = 1
          tip_point = rivers[river_id].tipPoint()
          tip_angle = rivers[river_id].tipAngle()

          ids_series_params = t_ids_series_params()
          ids_series_params[river_id] = solver.integrate_new(integration_params, tip_point, tip_angle)\end{mintedbox}

    \section{Reguły wzrostu i bifurkaji, zapisywanie i wczytywanie z pliku, klasa Model}
      \begin{figure}[H]
        \centering
        \includegraphics[width=0.5\textwidth]{figs/program_dependecy_graph.png}        
        \caption {Graph zależności pomiędzy modułami programu.}
        \label{program_strucutre}
      \end{figure}

    Przedstawione powyżej klasy biblioteki riversim już są wystarczają dla symulacji sieci rzecznych. Ale dla prostszego wykorzystania programu była stworzona klasa Model która zawiera wszystkie struktury danych programu, a tak że metody z regułami dla bifurkacji i wzrostu. Korzystajac z klasi Model możemy zapisać danę do pliku JSON, lub odczytać geometrie i wartości paratmetrów z pliku JSON:

    \begin{mintedbox}{python}
      model = Model()
      model.initializeDirichlet();
      save(model, "river_initializet_to_dirichlet.json")
      
      model_dirichlet = Model()
      open(model_dirichlet, "river_initializet_to_dirichlet.json")\end{mintedbox}


  \chapter{Weryfikacja i walidacja oprogramowania}

    %Розв'язання росту мережі річки в полі Лапласа є складною задачею. Щоб отримати наближений розв'язок були використані методи дискретизації. Способи дискретизації включали в себе як і заміну гладких ліній мережі на дискретні із подальшим зменшення кількості точок дискретизації в залежності від кривизни. Дискретизація регіону на чотирикутні елементи і ступінь квадратури в кожному елементі. Кількість елементів суми для обчислення інтегралу параметрів довкола джерела. Але відомо що в границі із ростом дескритизації:
    Solving the growth of the river network in the Laplace field is a difficult task. Discretization methods were used to obtain an approximate solution. Discretization methods included the replacement of smooth network lines with discrete ones, followed by a reduction in the number of discretization points depending on the curvature. Discretization of the region into quadrilateral elements and the degree of quadrature in each element. The number of elements of the sum for calculating the integral of the parameters around the source. But it is known that in the limit of high descritization:

    \begin{equation}
      \label{convergence}
      \lim_{n \to \infty} a_i(n)  = a_i
    \end{equation}

    %ми повинні отримати значення аналітичного розв'язку.
    we must obtain the value of the analytical solution.
    
    \section{Zbiezność calkowania i porownanie z wynikiem analitycznym}

    %В роботі Ґубєц \cite{gubiec2008fingered} було отримано вираз для швидкості $\upsilon(H)$ взросту одної річки в наступних умовах: регіон прямокутної форми, висота котрого прямує до безмежності, ширина рівна $2$. На нижній грані звідки посередині звідки і зростає одна гілка річки маємо поглинаючі граничні умови ($\phi(0, y) = 0$), ізолюючі граничні умови на бокових гранях ($(\nabla \phi(x, y))_{\vec{n}} = 0$) і маємо сталий потік на безмежній відстані на верхній грані ($(\nabla \phi(x, y))_{\vec{n}} = 1$). 
    In the work of Gubiec et al.\cite{gubiec2008fingered}, an expression was obtained for the rate $\upsilon(H)$ of the growth of one river under the following conditions: a rectangular region, the height of which goes to infinity, the width is $2$. On the lower face, from where in the middle, from where one branch of the river grows, we have absorbing boundary conditions ($\phi(0, y) = 0$), insulating boundary conditions on the side faces ($(\nabla \phi(x, y))_{ \vec{n}} = 0$) and we have a constant flow at an infinite distance on the upper face ($(\nabla \phi(x, y))_{\vec{n}} = 1$).

    \begin{equation}
      \label{velocity_analytical}
      \upsilon(H) = \sqrt{\frac{2}{\frac{\pi}{2}\coth(\frac{\pi}{2}H)}} \,.
    \end{equation}
    
    %В нашому випадку ми не можемо задати безмежну відстань верхньої грані, тому ми обмежимося достатньо витягнутим прямокутником ($50/2$)

  \chapter{Podsumowanie}

  \section*{Acknowledgements}

  \bibliographystyle{unsrt_initials} %ieeetr
  \bibliography{bibliography}

  \appendix

  \chapter{Główna pętla programu}
    
    Instalacja biblioteki riversim w Python3 (tylko Linux):
    
    \begin{mintedbox}{bash} 
      python3 -m pip install riversim\end{mintedbox}
    
    Skrypt Python symulujący rozwój sieci rzecznej napisany w oparciu biblioteki riversm:

    \begin{mintedbox}{python} 
      from riversim import *
      import numpy as np

      m = Model()
      m.InitializeDirichlet()

      solver = Solver(m.solver_params)
      triangle = Triangle(m.mesh_params)
      mesh = TethexMesh()

      dynamic_river_ids = m.rivers.tipBranchesIds()

      for i in range(m.number_of_steps):
          m.boundary = BoundaryGenerator(\
              m.sources, \
              m.region, \
              m.rivers, \
              m.region_params)

          num_of_intersects = NumOfBoundaryIntersection(m.boundary, m.rivers.tipBoundary())
          if num_of_intersects > 0:
              break

          empt_rivers = Rivers()
          empt_source = Sources()
          only_boundary = BoundaryGenerator(empt_source, m.region, empt_rivers, m.region_params)
          distance_to_boundary = DistanceFromPointsToBoundary(only_boundary, m.rivers.tipPoints())
          if distance_to_boundary <= m.integr_params.integration_radius:
              break

          if len(m.boundary.vertices) == 0:
              break 

          # mesh will be refined aroud growing tip points
          tip_points = t_PointList()
          for id in dynamic_river_ids:
              tip_points.append(m.rivers[id].tipPoint())
          triangle.mesh_params.tip_points = tip_points
          mesh = triangle.generate(m.boundary, m.region.holes)
              
          solver.openMesh(mesh)
          for j in range(m.solver_params.adaptive_refinment_steps + 1):
              if j > 0:
                  solver.refineGrid()
              solver.setupSystem()
              solver.assembleSystem(m.boundary_conditions)
              solver.solve()

          id_series_params = t_ids_series_params()
          max_a1 = 0
          for id in dynamic_river_ids:
              tip_point = m.rivers[id].tipPoint()
              tip_angle = m.rivers[id].tipAngle()
              id_series_params[id] = solver.integrate_new(m.integr_params, tip_point, tip_angle)
              if id_series_params[id][0] > max_a1:
                  max_a1 = id_series_params[id][0]

          for id_series_param in id_series_params:
              id = id_series_param.key()
              series_param = id_series_param.data()
              if m.qGrowth(series_param):
                  l = m.rivers[id].lenght()
                  if m.qBifurcate(series_param, l):
                      tip_point = m.rivers[id].tipPoint()
                      tip_angle = m.rivers[id].tipAngle()
                      br_left = Branch(tip_point, tip_angle + m.bifurcation_angle)
                      br_left.addPoint(Polar(m.ds, 0), m.region_params.river_boundary_id)
                      br_right = Branch(tip_point, tip_angle - m.bifurcation_angle)
                      br_right.addPoint(Polar(m.ds, 0), m.region_params.river_boundary_id)
                      ids = m.rivers.addSubBranches(id, br_left, br_right)

                      # add new branches
                      dynamic_river_ids.append(ids.left)
                      dynamic_river_ids.append(ids.right)

                      # and remove parent from growth evaluation
                      for f in range(len(dynamic_river_ids)):
                          if dynamic_river_ids[f] == id:
                              del dynamic_river_ids[f]
                              break
                  else: 
                      m.rivers[id].addPoint(\
                          m.nextPoint(series_param, l, max_a1),\
                          m.region_params.river_boundary_id)
              else:
                  # remove river from growth evaluation
                  for f in range(len(dynamic_river_ids)):
                      if dynamic_river_ids[f] == id:
                          del dynamic_river_ids[f]
                          break

          if debug:
              save(m, "debug " + str(i) + ".json")

          if not dynamic_river_ids:
              break
      \end{mintedbox}

  %\chapter{Przykładowe dane wejściowe algorytmu}

\end{document}